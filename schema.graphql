input acceptCircleTermsOfUseInput {
  # Id of the ToU to accept
  termsOfUseId: String!

  # Id of the user who accepts
  userId: String!
  clientMutationId: String
}

type acceptCircleTermsOfUsePayload {
  viewer: Viewer
  termsOfUse: CircleTermsOfUse
  clientMutationId: String
}

input addCircleMemberInput {
  circleId: String!
  userId: String
  pseudo: String
  email: String
  parentId: String
  parentEmail: String
  parentPseudo: String
  clientMutationId: String
}

type addCircleMemberPayload {
  edge: CircleEdge
  viewer: Viewer
  circle: Circle
  clientMutationId: String
}

input addCircleMembersInput {
  # Id of the circle to update
  circleId: String!

  # Id of the users to add
  users: [String]
  clientMutationId: String
}

type addCircleMembersPayload {
  edge: CircleEdge
  viewer: Viewer
  clientMutationId: String
}

input addMsgInput {
  # The ID of the chat to add the message
  chatId: String
  message: MessageInput
  clientMutationId: String
}

type addMsgPayload {
  edge: ChatEdge
  viewer: Viewer
  clientMutationId: String
}

input addMsgSubscriptionInput {
  # The ID of the chats to subscribe to
  chatIds: [String]
  clientSubscriptionId: String
}

type addMsgSubscriptionPayload {
  chat: Chat
  edge: ChatEdge
  viewer: Viewer
  clientSubscriptionId: String
}

input addParentMemberInput {
  circleId: String!
  parent1Id: String
  parent1Email: String
  parent2Id: String
  parent2Email: String
  childPseudo: String
  clientMutationId: String
}

type addParentMemberPayload {
  edge: CircleEdge
  viewer: Viewer
  clientMutationId: String
}

input addPendingSecondaryOrganizerInput {
  # The IDs of the sportunities to update
  sportunityIDs: [String]!

  # pending organizer input
  pendingOrganizer: PendingOrganizerInput!
  clientMutationId: String
}

type addPendingSecondaryOrganizerPayload {
  viewer: Viewer
  clientMutationId: String
}

# Represents an address input type
input AddressInput {
  # The address
  address: String!

  # The name of the country
  country: String!

  # The name of the city
  city: String!
  zip: String
}

# A physical address
type AddressModel {
  # The address
  address: String!

  # The ISO ALPHA-2 Code of this country
  country: String!

  # The name of the city
  city: String!

  # The zip code
  zip: String

  # An address position
  position: PositionType
}

input addSecondaryOrganizerInput {
  # The IDs of the sportunities to update
  sportunityIDs: [String]!

  # Organizer input
  organizer: OrganizerInput!
  clientMutationId: String
}

type addSecondaryOrganizerPayload {
  viewer: Viewer
  clientMutationId: String
}

input addSportunityImageInput {
  # The ID of the sportunity to update
  sportunityID: String!
  clientMutationId: String
}

type addSportunityImagePayload {
  sportunity: Sportunity
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

# Represents the global statistics for the application
type AdminStatistics {
  # Number of users in the application
  userNumber: Int

  # Number of sportunities in the application
  sportunityNumber: Int
}

# Ask Mango Pay to get the amount on current user's wallet
type AmountOnWallet {
  # Total amount on the wallet
  amountOnWallet: TotalAmountOnWallet

  # Locked amount on the wallet : to pay booked sportunities
  lockedAmount: LockedAmountOnWallet
}

# Answers for members of the cirle
input Answers {
  userId: String!
  filledInformation: [Information]
}

input askCarPoolingInput {
  # The ID of the sportunity
  sportunityID: String!
  clientMutationId: String
}

type askCarPoolingPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

# Asked informations for a specific circle
type askedInformation {
  # The ID of an object
  id: ID!

  # Name of the asked information
  name: String

  # Type of the asked information
  type: AskedInformationType

  # Tells if this the owner that will fill this field
  filledByOwner: Boolean
  form: CircleInformationFormOutput
}

# Represents a list of asked information for a specific circle
input AskedInformation {
  # Id of the asked information (if exsits)
  id: String

  # The name of the asked information
  name: String!

  # The type of the asked information
  type: AskedInformationType!

  # Tells if this is the owner that will fill this information
  filledByOwner: Boolean!
}

# Represents a list of asked information for a specific circle
input AskedInformationInput {
  # Id of the asked information (if exsits)
  id: String

  # The name of the asked information
  name: String!

  # The type of the asked information
  type: AskedInformationType!

  # Tells if this is the owner that will fill this information
  filledByOwner: Boolean!
}

# Gives the type of an asked information
enum AskedInformationType {
  # String
  TEXT

  # Integer
  NUMBER

  # Boolean
  BOOLEAN

  # Address
  ADDRESS

  # Date
  DATE

  # Phone number
  PHONE_NUMBER
}

input askNewValidationMailInput {
  # Pseudo of the user that wants to receive the validation mail
  pseudo: String

  # Email of the user that wants to receive the validation mail
  email: String
  clientMutationId: String
}

type askNewValidationMailPayload {
  viewer: Viewer
  clientMutationId: String
}

# An assistant type, regarding its sport
type AssistantType implements Node {
  # The ID of an object
  id: ID!

  # Return a name: TranslatedString
  name: TranslatedString
}

# Authorized accounts output type
type AuthorizedAccounts {
  # Id of the current user
  id: String

  # Pseudo of the current user
  pseudo: String

  # Avatar of the current user
  avatar: String

  # The type of the current user
  profileType: UserProfileType

  # Gives the number of unread notifications for this user
  numberOfUnreadNotifications: Int

  # Gives the number of unread chats for this user
  unreadChats: Int

  # List of authorized accounts with corresponding tokens
  accounts: [AuthorizedAccountsList]
}

# List of authorized accounts with corresponding tokens
type AuthorizedAccountsList {
  # Id
  id: String

  # Pseudo
  pseudo: String

  # Avatar
  avatar: String

  # Token for this user
  token: String

  # Level of the authorization
  authorization_level: ManagementAuthorizationLevels

  # Gives the number of unread notifications for this user
  numberOfUnreadNotifications: Int

  # Gives the number of unread chats for this user
  unreadChats: Int

  # List of sub accounts with corresponding tokens for this authorized account
  subAccounts: [AuthorizedUserSubAccounts]
}

# List of users who can create / manage this account
type AuthorizedManager {
  # Return a Users for a given id
  user: User

  # Level of the authorization
  authorization_level: ManagementAuthorizationLevels
}

# List of users who can create / manage this account
input AuthorizedManagerInput {
  # Id of the authorized user
  user: String

  # Level of authorization
  authorization_level: ManagementAuthorizationLevels
}

# List of sub accounts with corresponding tokens for this authorized account
type AuthorizedUserSubAccounts {
  # Id
  id: String

  # Pseudo
  pseudo: String

  # Avatar
  avatar: String

  # Token for this user
  token: String

  # Gives the number of unread notifications for this user
  numberOfUnreadNotifications: Int

  # Gives the number of unread chats for this user
  unreadChats: Int
}

# Represent a user's preference for his participant's availability stats
type availabilityStats {
  # Get the current statistic
  stat1: StatisticName

  # Get the current statistic
  stat2: StatisticName

  # Get the current statistic
  stat3: StatisticName

  # Get the current statistic
  stat4: StatisticName

  # Get the current statistic
  stat5: StatisticName
}

# A bank account
type BankAccount {
  # The ID of an object
  id: ID!

  # First line of the address
  addressLine1: String

  # Second line of the address
  addressLine2: String

  # City of the owner of the bank account
  city: String

  # Postal code of the owner of the bank account
  postalCode: String

  # Country of the owner of the bank account
  country: String

  # Name of the owner of the bank account
  ownerName: String

  # IBAN of the bank account
  IBAN: String

  # BIC of the bank account
  BIC: String
}

# Response from Mango Pay to create a bank wire
type BankWireToWallet {
  # Wire Reference to write in wire description
  wireReference: String

  # Type of the receiving bank account
  bankAccountType: String

  # Owner Name of the bank account receiving the wire
  ownerName: String

  # Owner Address of the bank account receiving the wire
  ownerAddress: String

  # IBAN of the receiving bank account
  IBAN: String

  # BIC of the receiving bank account
  BIC: String
}

# Tells if the current user can test some specific features
type BetaTester {
  # Feature that allow to define specific prices for invited circles to sportunities
  circlePrices: Boolean

  # Feature that allow to add statistics on sportunities
  statistics: Boolean

  # Feature that allow to add sub accounts and authorized users
  superUser: Boolean

  # Feature that allow to add secondary organizers to sportunities
  secondaryOrganizers: Boolean
}

input bookCarPoolingInput {
  # The ID of the sportunity
  sportunityID: String!

  # The ID of the car-pooling to book
  carPoolingID: String!

  # Bookers ID
  userID: String!
  clientMutationId: String
}

type bookCarPoolingPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

# Let the user choose if he wants to receive notifications
type Business {
  # Name of the business
  businessName: String

  # Generic business email
  businessEmail: Email

  # The address of a user
  headquarterAddress: AddressModel

  # VAT number of the business
  VATNumber: String
}

# Let the user choose if he wants to receive notifications
input BusinessInput {
  # Name of the business
  businessName: String

  # Generic business email
  businessEmail: Email

  # Address of the business headquarters
  headquarterAddress: AddressInput

  # VAT number of the business
  VATNumber: String
}

# List of sportunities or users the current user added to his calendar
type Calendar {
  # The list of all Sportunities
  sportunities(
    after: String
    first: Int
    before: String
    last: Int

    # Description of a filter in Sportunity
    filter: Filter

    # ID of the user we want to chat with
    userId: String

    # ID of the sportunity wanted
    id: String
    orderBy: Sportunities_Order
  ): SportunityConnection

  # Return a bunch of Users for a given array of id
  users: [User]

  # Preferences of calendar synchronization
  preferences: CalendarPreferences
  user_status: [User_Status]
}

# List of sportunities or users the current user added to his calendar
input CalendarInput {
  # List of sportunities the current user added to his calendar
  sportunities: [String]

  # List of users the current user added to his calendar
  users: [String]

  # Preferences of calendar synchronization
  preferences: CalendarPreferencesInput
}

# Preferences of calendar synchronization
type CalendarPreferences {
  # List of synchronized events for current user
  own_synchronized_status: [SportunityStatus]
}

# Preferences of calendar synchronization
input CalendarPreferencesInput {
  # List of synchronized events for current user
  own_synchronized_status: [SportunityStatus]
}

# If a user cancel his event booking, then he'll wait for someone to replace him
#
#      If he's not replaced, he'll have to pay his booking
enum cancelBookinStatus {
  # Canceling user is waiting to be replaced
  PENDING

  # Canceling user has been replaced
  REPLACED

  # The organizer refused the participation of this user
  REFUSED_BY_ORGANIZER
}

input cancelCarPoolingBookInput {
  # The ID of the sportunity
  sportunityID: String!

  # The ID of the car-pooling to cancel the book
  carPoolingID: String!

  # Bookers ID
  userID: String!
  clientMutationId: String
}

type cancelCarPoolingBookPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

# Represent a user canceling his booking to a Sportunity
type Canceling {
  # Return a Users for a given id
  canceling_user: User

  # Tells if the user has been replaced or not
  status: cancelBookinStatus

  # Date of the cancelation
  cancelation_date: DateTime
}

input cancelSportunityInput {
  # The IDs of the sportunities to cancel
  sportunityIDs: [String]!
  clientMutationId: String
}

type cancelSportunityPayload {
  viewer: Viewer
  clientMutationId: String
}

# Response from Mango Pay to register card information
type cardRegistration {
  # CardRegistration Id to pass to mutation to complete registration
  cardRegistrationId: String

  # A specific value to pass to the CardRegistrationURL
  preregistrationData: String

  # A special key to use when registering a card
  accessKey: String

  # The URL to submit the card details form to
  cardRegistrationURL: String
}

# A car pooling
type CarPooling {
  # The ID of an object
  id: ID!

  # Return a Users for a given id
  driver: User

  # The address of a user
  address: AddressModel

  # Departure date
  starting_date: DateTime

  # Total number of sits
  number_of_sits: Int

  # Return a bunch of Users for a given array of id
  passengers: [User]
}

# Represents a car pooling input
input CarPoolingInput {
  # Id of the driver
  driver: String

  # Address of the departure
  address: AddressInput

  # Date of the departure
  starting_date: String

  # Number of available sits in the car
  number_of_sits: Int
}

# A certificate for a sport
type Certificate {
  # The ID of an object
  id: ID!

  # Return a name: TranslatedString
  name: TranslatedString
}

# The level of a user for a given sport
type CertificateDescriptor {
  # Return the certificate
  certificate: Certificate

  # Tells if actual certificate has been validated by Sportunity Administration
  validation: CertificateValidation!
}

# Represents a certificate descriptor input
input CertificateDescriptorInput {
  # Id of the certificate
  certificate: String!

  # Tells users certificate has been validated
  validation: CertificateValidation
}

# Represents a certificate input type
input CertificateInput {
  # The name of the certificate in different language
  name: StringTranslatedInput!
}

# Specifies if a sport certificate is validated for a specific user
enum CertificateValidation {
  # Waiting for a validation
  PENDING

  # Certificate validation has been refused
  REJECTED

  # Certificate has been validated
  VALIDATED
}

input changePasswordInput {
  # Pseudo of the user that wants to change his password
  pseudo: String

  # Email of the user that wants to change his password
  email: String
  clientMutationId: String
}

type changePasswordPayload {
  viewer: Viewer
  clientMutationId: String
}

# Represents a chat
type Chat implements Node {
  # The ID of an object
  id: ID!

  # A Sportunity
  sportunity(
    # ID of the sportunity wanted
    id: ID
  ): Sportunity

  # A circle
  circle(
    # ID of the circle wanted
    id: ID
  ): Circle

  # Return a bunch of Users for a given array of id
  users: [User]

  # The list of all messages sent to this entity
  messages(
    after: String
    first: Int
    before: String
    last: Int

    # The Id of the expeditor
    from: String
  ): MessageConnection

  # Get the number of messages in the current chat
  messageCount: Int

  # Current user has read the chat or not ?
  read: Boolean

  # Tells if the current chat is active or not
  isActive: Boolean
}

# A connection to a list of items.
type ChatConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ChatEdge]

  # Total number of tags
  count: Int
}

# An edge in a connection.
type ChatEdge {
  # The item at the end of the edge
  node: Chat

  # A cursor for use in pagination
  cursor: String!
}

# A Circle of friends
type Circle implements Node {
  # The ID of an object
  id: ID!

  # The name of the circle
  name: String

  # Description of the circle
  description: String

  # Return a Users for a given id
  owner: User

  # The address of a user
  address: AddressModel

  # The sport information for a circle
  sport: CircleSport
  coOwners: [User]

  # The kind of Circle
  mode: CircleKind!

  # The type of this circle
  type: CircleTypeEnum
  members: [User]
  memberStatus: [memberStatus]

  # Return a bunch of Users for a given array of id
  memberParents: [User]

  # The number of users in the circle
  memberCount: Int!

  # Tells if the members of the circle can add new members
  isCircleUpdatableByMembers: Boolean

  # Tells if the members of this circle can invite this circle in a sportunity
  isCircleUsableByMembers: Boolean

  # Tells if the circle can be accessed from its url for non-members
  isCircleAccessibleFromUrl: Boolean
  askedInformation: [askedInformation]
  membersInformation: [membersInformation]

  # The list of all circles belonging to a given object
  subCircles(
    after: String
    first: Int
    before: String
    last: Int

    # Types of wanted circles
    type: [CircleTypeEnum]

    # Description of a filter in Sportunity
    filter: CirclesFilter
  ): CircleConnection

  # Payment models for this circle
  paymentModels: [CirclePaymentModel]
  memberConditions: [MemberCondition]
  circlePreferences: CirclePreferences
  sportunities: SportunityConnection

  # Returns the ToU for a specified circle
  termsOfUses: [CircleTermsOfUse]
}

# A connection to a list of items.
type CircleConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [CircleEdge]

  # Total number of tags
  count: Int
}

# An edge in a connection.
type CircleEdge {
  # The item at the end of the edge
  node: Circle

  # A cursor for use in pagination
  cursor: String!
}

# Represents a position on Earth
type CircleFilterLatLng {
  # The latitude of the position
  lat: Float

  # The longitude of the position
  lng: Float

  # Radius around coords to look for sportunities
  radius: Int
}

# Represents a sport saved in filter
type CircleFilterSport {
  # Get a sport for object that have only one
  sport(
    # ID of the sport wanted
    id: ID
  ): Sport

  # Return a levels: TranslatedSportLevel
  levels: [Translated]
}

# A form for personal information asked for circles
type CircleInformationFormOutput {
  # The ID of an object
  id: ID!
  name: String

  # The list of all circles belonging to a given object
  circles(
    after: String
    first: Int
    before: String
    last: Int

    # Types of wanted circles
    type: [CircleTypeEnum]

    # Description of a filter in Sportunity
    filter: CirclesFilter
  ): CircleConnection
  askedInformation: [askedInformation]
}

# Represents a circle input type
input CircleInput {
  # Name of the circle
  name: String!

  # If null, taking current session as owner
  owner: String

  # Description of the circle
  description: String

  # The kind of Circle
  mode: CircleKind

  # The type of this circle
  type: CircleTypeEnum

  # The address of the Circle
  address: AddressInput

  # Selected sport, levels, positions and certificates
  sport: CircleSportInput

  # Tells if the members of the circle can add new members
  isCircleUpdatableByMembers: Boolean

  # Tells if the members of this circle can invite this circle in a sportunity
  isCircleUsableByMembers: Boolean

  # Tells if the circle can be accessed from its url for non-members
  isCircleAccessibleFromUrl: Boolean

  # Ids of the circles that should be merged into one circle
  subCircles: [String]
  circlePreferences: CirclePreferencesInput
}

# Specifies which kind of circle it is
enum CircleKind {
  # The circle is public that means everyone can see it
  #       On the other side only and admin can change the members of this circle
  PUBLIC

  # The circle is private, only its owner can see it and modify the members
  PRIVATE
}

# Specifies which type of circle it is
enum CircleListTypeEnum {
  # My circles
  MY_CIRCLES

  # Circles I'm in
  CIRCLES_I_AM_IN

  # Children / teams circles
  CHILDREN_CIRCLES

  # Public circles
  PUBLIC_CIRCLES
}

# All the members from current user 's circles
type CircleMemberOutput {
  # Return a Users for a given id
  user: User
  circles: [CirclesMemberIsIn]
}

# Gives the status of a member in a circle
enum CircleMemberStatus {
  # Member is active
  ACTIVE

  # Member is injured
  INJURED

  # Member is inactive
  INACTIVE

  # Any other status
  OTHER
}

# A payment model for a circle
type CirclePaymentModel {
  # The ID of an object
  id: ID!

  # The name of the payment model
  name: String

  # Conditions available for this payment model
  conditions: [CirclePaymentModelCondition]

  # Get the Prices of an object
  price: Price

  # The list of all circles belonging to a given object
  circles(
    after: String
    first: Int
    before: String
    last: Int

    # Types of wanted circles
    type: [CircleTypeEnum]

    # Description of a filter in Sportunity
    filter: CirclesFilter
  ): CircleConnection
}

# A payment model condition
type CirclePaymentModelCondition {
  # The ID of an object
  id: ID!

  # The name of the payment model condition
  name: String

  # Get the Prices of an object
  price: Price
  conditions: [PaymentModelConditionList]
}

# Represents a circle payment model condition input type
input CirclePaymentModelConditionInput {
  # Id of the condition to update
  id: String

  # Name of the condition
  name: String!

  # The price for this condition
  price: PriceInput
  conditions: [PaymentModelConditionListInput]
}

# Represents a circle payment model input type
input CirclePaymentModelInput {
  # Id of the payment model to update
  id: String

  # Name of the payment model
  name: String!

  # Conditions for this payment model
  conditions: [CirclePaymentModelConditionInput]

  # The price for this payment model
  price: PriceInput
  circles: [String]!
}

# Information of the circle
type CirclePreferences {
  # Is this a circle containing only children ?
  isChildrenCircle: Boolean
}

# Information of the circle
input CirclePreferencesInput {
  # Is this a circle containing only children ?
  isChildrenCircle: Boolean
}

# Allow you to control which results are returned
input CirclesFilter {
  # Filter by location constraint
  location: LocationConstraint

  # Filter by sport name and level constraint
  sport: [SportConstraint]

  # Type of circle (adults, children, ...)
  type: CircleTypeEnum

  # Types of circle (adults, children, ...)
  types: [CircleTypeEnum]

  # Few characters to search for a circle
  nameCompletion: String

  # Modes (private, public)
  modes: [CircleKind]

  # Filter by owners
  owners: [String]

  # Filter by isCircleUsableByMember
  isCircleUsableByMember: Boolean
}

# List of circles
type CirclesMemberIsIn {
  # A circle
  circle(
    # ID of the circle wanted
    id: ID
  ): Circle
  isActive: Boolean
}

# The sport of a circle
type CircleSport {
  # Get a sport for object that have only one
  sport(
    # ID of the sport wanted
    id: ID
  ): Sport

  # Return a levels: TranslatedSportLevel
  levels: [Translated]
}

# Represents a circle's sport input
input CircleSportInput {
  # Id of the sport
  sport: String!

  # Ids of the levels
  levels: [String]
}

# Statistics for an organizer
type CirclesStatisticsOrganizer {
  # Get the current statistic
  statisticName: StatisticName

  # Return a Users for a given id
  participant: User

  # Value of the statistic
  value: Int

  # Tells if the current stat is about availability
  isAvailabilityStat: Boolean
}

# A terms of use for a circle
type CircleTermsOfUse {
  # The ID of an object
  id: ID!

  # The name of the ToU
  name: String

  # The link of the ToU
  link: String

  # The content of the ToU
  content: String

  # The list of all circles belonging to a given object
  circles(
    after: String
    first: Int
    before: String
    last: Int

    # Types of wanted circles
    type: [CircleTypeEnum]

    # Description of a filter in Sportunity
    filter: CirclesFilter
  ): CircleConnection
  acceptedBy: [TermsOfUseAcceptedBy]

  # Date of ToU creation
  creation_date: DateTime

  # Date of last ToU update (acceptations not included)
  update_date: DateTime
}

# Represents a circle terms of use input type
input CircleTermsOfUseInput {
  # Id of the terms of use to update
  id: String

  # Name of the terms of use
  name: String!

  # Link of the terms of use
  link: String

  # Conditions of the terms of use
  content: String
  circles: [String]
}

# Specifies which type of circle it is
enum CircleTypeEnum {
  # This circle will contain only adults
  ADULTS

  # This circle will contain only children
  CHILDREN

  # This circle will contain only teams
  TEAMS

  # This circle will contain only clubs
  CLUBS

  # This circle will contain only companies
  COMPANIES
}

# A composition for a team
input CompositionInput {
  # Name of the composition
  name: String

  # Id of the owner
  owner: String

  # Field image choosen for this composition
  fieldImage: String

  # List of users and their position given in %
  users: [CompositionUsersInput]
}

# A composition for a team
type CompositionOutput {
  # The ID of an object
  id: ID!

  # Name of the composition
  name: String

  # Return a Users for a given id
  owner: User

  # Field image choosen for this composition
  fieldImage: String

  # List of users and their position given in %
  users: [CompositionUsers]
}

# Position
type CompositionUserPosition {
  # x Percentage of the user on the image (x1000)
  xPercentage: Int

  # y Percentage of the user on the image (x1000)
  yPercentage: Int
}

# Position
input CompositionUserPositionInput {
  # x Percentage of the user on the image (x1000)
  xPercentage: Int

  # y Percentage of the user on the image (x1000)
  yPercentage: Int
}

# List of users and their position given in % (x 1000)
type CompositionUsers {
  # Return a Users for a given id
  user: User

  # Position
  position: CompositionUserPosition
}

# List of users and their position given in % (x 1000)
input CompositionUsersInput {
  # Id of the user
  user: String

  # Position
  position: CompositionUserPositionInput
}

# Represent any currency Sportunity supports
enum Currency {
  CHF
  EUR
  USD
}

scalar DateTime

input deleteAskedInformationFormInput {
  id: String!
  clientMutationId: String
}

type deleteAskedInformationFormPayload {
  viewer: Viewer
  clientMutationId: String
}

input deleteCarPoolingInput {
  # The ID of the sportunity
  sportunityID: String!

  # The ID of the car-pooling to delete
  carPoolingID: String!
  clientMutationId: String
}

type deleteCarPoolingPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

input deleteCircleInput {
  circleId: String!
  clientMutationId: String
}

type deleteCirclePayload {
  edge: CircleEdge
  viewer: Viewer
  clientMutationId: String
}

input deleteCirclePaymentModelInput {
  paymentModelId: String!
  clientMutationId: String
}

type deleteCirclePaymentModelPayload {
  viewer: Viewer
  clientMutationId: String
}

input deleteCompositionInput {
  # The ID of the composition to delete
  compositionId: String
  clientMutationId: String
}

type deleteCompositionPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input deleteInfrastructureInput {
  infrastructureId: String!
  clientMutationId: String
}

type deleteInfrastructurePayload {
  edge: VenueEdge
  viewer: Viewer
  clientMutationId: String
}

input deletePaymentMethodInput {
  paymentMethodId: String
  clientMutationId: String
}

type deletePaymentMethodPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input deleteSlotInput {
  slotId: String!

  # Tells if the serie of slot should be deleted
  deleteSlotSerie: Boolean
  clientMutationId: String
}

type deleteSlotPayload {
  edge: VenueEdge
  viewer: Viewer
  clientMutationId: String
}

# The Email scalar type represents E-Mail addresses compliant to RFC 822.
scalar Email

# Let the user choose if he wants to receive emails
type EmailPreferences {
  # Email when user organizes a sportunity
  sportunityNewMainOrganizer: Boolean

  # Email when user is a secondary organizer of a new sportunity
  sportunityNewSecondaryOrganizer: Boolean

  # Email when user is a venue of a new sportunity
  sportunityNewVenueOrganizer: Boolean

  # Email when user is invited to a new sportunity
  sportunityNewInvited: Boolean

  # Email when a followed user creates a sportunity
  sportunityNewFollower: Boolean

  # Email when organizer cancels his sportunity
  sportunityCancelMainOrganizer: Boolean

  # Email when a sportunity where user is secondary organizer is cancelled
  sportunityCancelSecondaryOrganizer: Boolean

  # Email when a sportunity where user is participant is cancelled
  sportunityCancelParticipant: Boolean

  # Email when user books a sportunity
  sportunityBooked: Boolean

  # Email when someone booked a sportunity where user is organizer
  sportunityBookedOrganizer: Boolean

  # Email when someone cancelled is booking to a sportunity
  sportunityBookerCancel: Boolean

  # Email when someone cancelled is booking to a sportunity where user is organizer
  sportunityBookerCancelOrganizer: Boolean

  # Email to remind user when he has an unread message
  chatUnReadMessage: Boolean

  # Email when organizer modifies his sportunity
  sportunityModifiedMainOrganizer: Boolean

  # Email when a sportunity where user is secondary organizer is modified
  sportunityModifiedSecondaryOrganizer: Boolean

  # Email when a sportunity where user is venue is modified
  sportunityModifiedVenueOrganizer: Boolean

  # Email when a sportuntiy were user is participant is modified
  sportunityModifiedParticipant: Boolean

  # Email when participant's payment has been done
  paymentConfirmationOnDDay: Boolean

  # Email for main organizer when he received a payment
  paymentReceivedMainOrganizer: Boolean

  # Email for secondary organizer when he received a payment
  paymentReceivedSecondaryOrganizer: Boolean

  # Email when user's certificate has been validated by admin user
  certificateValidated: Boolean
}

# Let the user choose if he wants to receive emails
input EmailPreferencesInput {
  # Email when user organizes a sportunity
  sportunityNewMainOrganizer: Boolean

  # Email when user is a secondary organizer of a new sportunity
  sportunityNewSecondaryOrganizer: Boolean

  # Email when user is a venue of a new sportunity
  sportunityNewVenueOrganizer: Boolean

  # Email when user is invited to a new sportunity
  sportunityNewInvited: Boolean

  # Email when a followed user creates a sportunity
  sportunityNewFollower: Boolean

  # Email when organizer cancels his sportunity
  sportunityCancelMainOrganizer: Boolean

  # Email when a sportunity where user is secondary organizer is cancelled
  sportunityCancelSecondaryOrganizer: Boolean

  # Email when a sportunity where user is participant is cancelled
  sportunityCancelParticipant: Boolean

  # Email when user books a sportunity
  sportunityBooked: Boolean

  # Email when someone booked a sportunity where user is organizer
  sportunityBookedOrganizer: Boolean

  # Email when someone cancelled is booking to a sportunity
  sportunityBookerCancel: Boolean

  # Email when someone cancelled is booking to a sportunity where user is organizer
  sportunityBookerCancelOrganizer: Boolean

  # Email to remind user when he has an unread message
  chatUnReadMessage: Boolean

  # Email when organizer modifies his sportunity
  sportunityModifiedMainOrganizer: Boolean

  # Email when a sportunity where user is secondary organizer is modified
  sportunityModifiedSecondaryOrganizer: Boolean

  # Email when a sportunity where user is venue is modified
  sportunityModifiedVenueOrganizer: Boolean

  # Email when a sportuntiy were user is participant is modified
  sportunityModifiedParticipant: Boolean

  # Email when participant's payment has been done
  paymentConfirmationOnDDay: Boolean

  # Email for main organizer when he received a payment
  paymentReceivedMainOrganizer: Boolean

  # Email for secondary organizer when he received a payment
  paymentReceivedSecondaryOrganizer: Boolean

  # Email when user's certificate has been validated by admin user
  certificateValidated: Boolean
}

# Who should be excluded from the invited list
type excludedInvitees {
  # Statuses of members to exclude
  excludedStatus: [CircleMemberStatus]

  # Return a bunch of Users for a given array of id
  excludedMembers: [User]

  # Should this event invite parents
  excludeParents: Boolean
}

# Who should be excluded from the invited list
input excludedInviteesInput {
  # Statuses of members to exclude
  excludedStatus: [CircleMemberStatus]

  # Ids of members to exclude
  excludedMembers: [String]

  # Should this event invite parents
  excludeParents: Boolean
}

# If participant by default = true, who should be excluded
type excludedParticipantByDefault {
  # Statuses of members to exclude
  excludedStatus: [CircleMemberStatus]

  # Return a bunch of Users for a given array of id
  excludedMembers: [User]

  # Should this event include parents as participant by default
  excludeParents: Boolean
}

# If participant by default = true, who should be excluded
input excludedParticipantByDefaultInput {
  # Statuses of members to exclude
  excludedStatus: [CircleMemberStatus]

  # Ids of members to exclude
  excludedMembers: [String]

  # Should this event include parents as participant by default
  excludeParents: Boolean
}

# A Feedback from a user on another Object
type Feedback implements Node {
  # The ID of an object
  id: ID!

  # The content of the feedback
  text: String

  # The grade associated to this feedback (1-5)
  rating: Int!

  # Return a Users for a given id
  author: User

  # When the feedback was written
  createdAt: DateTime!
}

# A connection to a list of items.
type FeedbackConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [FeedbackEdge]

  # Total number of tags
  count: Int
}

# An edge in a connection.
type FeedbackEdge {
  # The item at the end of the edge
  node: Feedback

  # A cursor for use in pagination
  cursor: String!
}

# Represents a feedback input type
input FeedbackInput {
  text: String!

  # The rating of the feedback
  rating: Int!

  # The id of the user which wrote the feedback
  author: String!

  # The date of creation of the feedback
  createdAt: String!
}

enum FeedbackOrder {
  # Order by date of creation of the feedback
  DATE

  # Order by the given rating
  RATING
}

# An object representing the feedback of the community
type Feedbacks {
  # The number of feedbacks
  count: Int!

  # The average rate given by the community
  averageRating: Float

  # The list of feedbacks on this object
  feedbacksList(
    after: String
    first: Int
    before: String
    last: Int

    # On which critera do you want to order the feedbacks
    orderBy: FeedbackOrder
  ): FeedbackConnection
}

# Allow you to control which results are returned
input Filter {
  # Filter by location constraint
  location: LocationConstraint

  # Filter by sport name and level constraint
  sport: [SportConstraint]

  # Status of sportunities
  status: SportunityStatus

  # Array of status of sportunities
  statuses: [SportunityStatus]

  # The interval of price to filter
  price: IntIntervalInput

  # The interval of dates to filter
  dates: StringIntervalInput

  # The interval of hours of the beginning hours to filter
  hours: IntIntervalInput

  # Kind of sportunities : PRIVATE or PUBLIC
  kind: SportunityKind

  # Sex restriction to filter sportunities
  sexRestriction: SexRestriction

  # Age restriction to filter sportunities
  ageRestriction: IntIntervalInput

  # ID of the users to get their sportunities
  users: [String]

  # ID of the circles to get sportunities those circles are invited in
  circles: [String]

  # ID of the sub-accounts to get their sportunities
  subAccounts: [String]

  # List of opponent Ids
  opponents: [String]

  # List of IDs of sportunity types to filter
  sportunityTypes: [String]
}

# Represents a position on Earth
type FilterLatLng {
  # The latitude of the position
  lat: Float

  # The longitude of the position
  lng: Float

  # Radius around coords to look for sportunities
  radius: Int
}

# Represents a sport saved in filter
type FilterSport {
  # Get a sport for object that have only one
  sport(
    # ID of the sport wanted
    id: ID
  ): Sport

  # Return a levels: TranslatedSportLevel
  levels: [Translated]
}

# Information of the game : opponent, season, ... 
type GameInformation {
  # Information about the opponent
  opponent: SportunityOpponentOutput
}

# Information of the game : opponent, season, ... 
input GameInformationInput {
  # Information about the opponent
  opponent: SportunityOpponentInput
}

# Information of the game : opponent, season, ... 
input GameInformationUpdateInput {
  # Information about the opponent
  opponent: SportunityOpponentUpdateInput
}

# Default page that is loading when a user logs in
enum HomePagePreference {
  # Find sportunities page / Explore
  FIND

  # My Sportunities page
  ORGANIZED
}

# An information filled
input Information {
  # Id of the asked information
  id: String!

  # The filled information
  value: String!
}

# Represents an infrastructure of a venue
type Infrastructure implements Node {
  # The ID of an object
  id: ID!
  venue: Venue

  # The name of the infrastructure (ex court 1)
  name: String!

  # The list of sports playable in an infrastructre
  sport: [Sport]

  # The a list slots
  slots(
    # ID of the infrastructure we want the avaialbe slots of
    id: ID

    # ID of the sportunity user is updating
    updatingSportunity: ID

    # Description of a filter in Sportunity
    filter: Filter
  ): [Slot]

  # Logo of the infrastructure
  logo: String

  # Get the Prices of an object
  price: Price
  authorized_managers: [InfrastructureAuthorizedManager]
}

# List of available authorizations levels for user to an infrastructure
enum InfrastructureAuthorizationLevels {
  # User can create timeslots as he wants
  FULL_CONSUMER

  # User can create timeslots on certain conditions
  CONSUMER
}

# List of users who can manage this infrastructure
type InfrastructureAuthorizedManager {
  # Return a Users for a given id
  user: User

  # A circle
  circle(
    # ID of the circle wanted
    id: ID
  ): Circle

  # Level of the authorization
  authorization_level: InfrastructureAuthorizationLevels
}

# List of users who can manage this infrastructure
input InfrastructureAuthorizedManagerInput {
  # Id of the authorized user
  user: String

  # Id of the authorized circle
  circle: String

  # Level of authorization
  authorization_level: InfrastructureAuthorizationLevels
}

# Represents an infrastructure input type
input InfrastructureInput {
  # The infrastructure id to update (if needed)
  id: String
  name: String!

  # The id of the sport available in the infrastructure
  sport: [String]

  # Logo of the infrastructure
  logo: String

  # The default price of the infrastructure
  price: PriceInput
  authorized_managers: [InfrastructureAuthorizedManagerInput]
}

# Represent an interval of Int
type IntInterval {
  # The lower bound of the interval
  from: Int

  # The upper bound of the interval
  to: Int
}

# Represent an interval input of Int
input IntIntervalInput {
  # The lower bound of the interval
  from: Int!

  # The upper bound of the interval
  to: Int!
}

# Represent a user invited to a Sportunity
type Invited {
  # Return a Users for a given id
  user: User

  # Tells the answer of the invited user
  answer: invitedUserAnswer
}

input invitedAnswersSurveyInput {
  # The ID of the sportunity to update
  sportunityID: String!

  # The ID of the user answering
  userId: String!
  answers: [SurveyInvitedAnswers]!
  clientMutationId: String
}

type invitedAnswersSurveyPayload {
  sportunity: Sportunity
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

# Represents an invited circle to a sportunity input type
input InvitedCircleInput {
  circle: String

  # Price that members of the current circle would pay if they book
  price: PriceInput

  # Tells if members of the current circle should be participants by default (for free sportunities only)
  participantByDefault: Boolean

  # If participant by default = true, who should be excluded
  excludedParticipantByDefault: excludedParticipantByDefaultInput

  # Who should be excluded from the invited list
  excludedInvitees: excludedInviteesInput
}

# Represents an invited user to a sportunity input type
input InvitedInput {
  user: String

  # The pseudo of the invited user
  pseudo: String

  # Tells if the organizer has accepted the invitation
  answer: invitedUserAnswer!
}

input InvitedListToAdd {
  # The ID of the user to invite
  invitedId: String

  # If the new user doesn't exist, define a pseudo for him
  invitedPseudo: String

  # If the new user doesn't exist, his email
  invitedEmail: String
}

# List of available status for invited users
enum invitedUserAnswer {
  WAITING

  # The user confirmed his booking
  YES

  # The user refused the invitation
  NO
}

# All the languages a user can speak
type Language {
  # The ID of an object
  id: ID!

  # Language code
  code: String

  # Language name
  name: String
}

# Represents a location constraint
input LocationConstraint {
  # The latitude of the center
  lat: Float

  # The longitude of the center
  lng: Float

  # The radius of the constraint
  radius: Float
}

# Locked amount on the wallet : to pay booked sportunities
type LockedAmountOnWallet {
  # The amount locked on the wallet
  cents: Int

  # Currency
  currency: Currency
}

input mailValidationInput {
  # Token to validate email address
  token: String!
  clientMutationId: String
}

type mailValidationPayload {
  viewer: Viewer
  clientMutationId: String
}

# List of available authorizations levels for user to another
enum ManagementAuthorizationLevels {
  # The authorized user can login, see sportunities ... but can't create anything or manage the account
  READER

  # The authorized user can login, see and create sportunities ... but can't manage the account
  WRITER

  # The authorized user can login, and manage everything in the account
  ADMIN
}

# Votes for man of the game for this sportunity
type manOfTheGameVotes {
  # Return a Users for a given id
  voter: User

  # Return a Users for a given id
  votedFor: User

  # Date of the vote
  date: DateTime
}

# Conditions that the member has chosen
type MemberCondition {
  # Return a Users for a given id
  member: User

  # Conditions chosen by the member
  chosenCondition: [CirclePaymentModelCondition]
}

# Members informations for a specific circle
type membersInformation {
  # The ID of an object
  id: ID!

  # Id of the asked information
  information: String

  # Return a Users for a given id
  user: User

  # Filled answer
  value: String
}

# Members status for a specific circle
type memberStatus {
  # Return a Users for a given id
  member: User
  status: CircleMemberStatus

  # Beginning of the status
  starting_date: DateTime

  # Ending of the status
  ending_date: DateTime
}

# Status for members of the cirle
input MemberStatusInput {
  memberId: String!
  status: CircleMemberStatus!
}

# The members that user is participating with
type MembersUserParticipatesWith {
  # Return a Users for a given id
  user: User

  # Number of times the user is participating to a sportunity with this member
  number: Int
}

# Represents a message
type Message implements Node {
  # The ID of an object
  id: ID!

  # The content of the message
  text: String!

  # Return a Users for a given id
  author: User

  # When the message was written
  created: DateTime!
}

# A connection to a list of items.
type MessageConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [MessageEdge]

  # Total number of tags
  count: Int
}

# An edge in a connection.
type MessageEdge {
  # The item at the end of the edge
  node: Message

  # A cursor for use in pagination
  cursor: String!
}

# Represents a message input type
input MessageInput {
  text: String!

  # The ID of the author of the message
  author: String!
}

type Mutation {
  newUser(input: newUserInput!): newUserPayload
  upUser(input: upUserInput!): upUserPayload
  reportUser(input: reportUserInput!): reportUserPayload
  mailValidation(input: mailValidationInput!): mailValidationPayload
  askNewValidationMail(input: askNewValidationMailInput!): askNewValidationMailPayload
  changePassword(input: changePasswordInput!): changePasswordPayload
  updatePassword(input: updatePasswordInput!): updatePasswordPayload
  unfollowUser(input: unfollowUserInput!): unfollowUserPayload
  setDefaultFilter(input: setDefaultFilterInput!): setDefaultFilterPayload
  setDefaultCircleFilter(input: setDefaultCircleFilterInput!): setDefaultCircleFilterPayload
  newSportunity(input: newSportunityInput!): newSportunityPayload
  newOpponentSportunity(input: newOpponentSportunityInput!): newOpponentSportunityPayload
  updateSportunity(input: updateSportunityInput!): updateSportunityPayload
  organizerAddParticipants(input: organizerAddParticipantsInput!): organizerAddParticipantsPayload
  organizerAddInviteds(input: organizerAddInvitedsInput!): organizerAddInvitedsPayload
  secondaryOrganizerPickRole(input: secondaryOrganizerPickRoleInput!): secondaryOrganizerPickRolePayload
  secondaryOrganizerCancelRole(input: secondaryOrganizerCancelRoleInput!): secondaryOrganizerCancelRolePayload
  secondaryOrganizerRefuseRole(input: secondaryOrganizerRefuseRoleInput!): secondaryOrganizerRefuseRolePayload
  newCarPooling(input: newCarPoolingInput!): newCarPoolingPayload
  updateCarPooling(input: updateCarPoolingInput!): updateCarPoolingPayload
  deleteCarPooling(input: deleteCarPoolingInput!): deleteCarPoolingPayload
  bookCarPooling(input: bookCarPoolingInput!): bookCarPoolingPayload
  cancelCarPoolingBook(input: cancelCarPoolingBookInput!): cancelCarPoolingBookPayload
  askCarPooling(input: askCarPoolingInput!): askCarPoolingPayload
  addEventImage(input: addSportunityImageInput!): addSportunityImagePayload
  removeEventImage(input: removeSportunityImageInput!): removeSportunityImagePayload
  invitedAnswersSurvey(input: invitedAnswersSurveyInput!): invitedAnswersSurveyPayload
  organizerPickDate(input: organizerPickSurveyDateInput!): organizerPickSurveyDatePayload
  addSecondaryOrganizer(input: addSecondaryOrganizerInput!): addSecondaryOrganizerPayload
  removeSecondaryOrganizer(input: removeSecondaryOrganizerInput!): removeSecondaryOrganizerPayload
  addPendingSecondaryOrganizer(input: addPendingSecondaryOrganizerInput!): addPendingSecondaryOrganizerPayload
  cancelSportunity(input: cancelSportunityInput!): cancelSportunityPayload
  newSport(input: newSportInput!): newSportPayload
  updateSport(input: updateSportInput!): updateSportPayload
  newSportunityType(input: newSportunityTypeInput!): newSportunityTypePayload
  updateSportunityType(input: updateSportunityTypeInput!): updateSportunityTypePayload
  removeSportunityType(input: removeSportunityTypeInput!): removeSportunityTypePayload
  newSportunityTypeStatus(input: newSportunityTypeStatusInput!): newSportunityTypeStatusPayload
  updateSportunityTypeStatus(input: updateSportunityTypeStatusInput!): updateSportunityTypeStatusPayload
  removeSportunityTypeStatus(input: removeSportunityTypeStatusInput!): removeSportunityTypeStatusPayload
  newAssistantType(input: newAssistantTypeInput!): newAssistantTypePayload
  updateAssistantType(input: updateAssistantTypeInput!): updateAssistantTypePayload
  removeAssistantType(input: removeAssistantTypeInput!): removeAssistantTypePayload
  newVenue(input: newVenueInput!): newVenuePayload
  updateVenue(input: updateVenueInput!): updateVenuePayload
  newSlot(input: newSlotInput!): newSlotPayload
  updateSlot(input: updateSlotInput!): updateSlotPayload
  deleteSlot(input: deleteSlotInput!): deleteSlotPayload
  newInfrastructure(input: newInfrastructureInput!): newInfrastructurePayload
  updateInfrastructure(input: updateInfrastructureInput!): updateInfrastructurePayload
  deleteInfrastructure(input: deleteInfrastructureInput!): deleteInfrastructurePayload
  addMsg(input: addMsgInput!): addMsgPayload
  readChat(input: readChatInput!): readChatPayload
  newCircle(input: newCircleInput!): newCirclePayload
  updateCircle(input: updateCircleInput!): updateCirclePayload
  deleteCircle(input: deleteCircleInput!): deleteCirclePayload
  addCircleMember(input: addCircleMemberInput!): addCircleMemberPayload
  addCircleMembers(input: addCircleMembersInput!): addCircleMembersPayload
  addParentMember(input: addParentMemberInput!): addParentMemberPayload
  removeParent(input: removeCircleParentInput!): removeCircleParentPayload
  removeCircleMember(input: removeCircleMemberInput!): removeCircleMemberPayload
  updateAskedInformation(input: updateAskedInformationInput!): updateAskedInformationPayload
  updateAskedInformationForm(input: updateAskedInformationFormInput!): updateAskedInformationFormPayload
  deleteAskedInformationForm(input: deleteAskedInformationFormInput!): deleteAskedInformationFormPayload
  updateFilledInformation(input: updateFilledInformationInput!): updateFilledInformationPayload
  relaunchMembersForAskedInformation(input: relaunchMembersForAskedInformationInput!): relaunchMembersForAskedInformationPayload
  newCirclePaymentModel(input: newCirclePaymentModelInput!): newCirclePaymentModelPayload
  updateCirclePaymentModel(input: updateCirclePaymentModelInput!): updateCirclePaymentModelPayload
  deleteCirclePaymentModel(input: deleteCirclePaymentModelInput!): deleteCirclePaymentModelPayload
  updateMemberStatus(input: updateCircleMemberStatusInput!): updateCircleMemberStatusPayload
  newTermsOfUse(input: newCircleTermsOfUseInput!): newCircleTermsOfUsePayload
  updateTermsOfUse(input: updateCircleTermsOfUseInput!): updateCircleTermsOfUsePayload
  removeTermsOfUse(input: removeCircleTermsOfUseInput!): removeCircleTermsOfUsePayload
  acceptTermsOfUse(input: acceptCircleTermsOfUseInput!): acceptCircleTermsOfUsePayload
  relaunchTermsOfUseValidation(input: relaunchMembersForTermsOfUseValidationInput!): relaunchMembersForTermsOfUseValidationPayload
  registerCardData(input: registerCardDataInput!): registerCardDataPayload
  registerBankAccount(input: registerBankAccountInput!): registerBankAccountPayload
  deletePaymentMethod(input: deletePaymentMethodInput!): deletePaymentMethodPayload
  readNotifications(input: readNotificationsInput!): readNotificationsPayload
  readNotification(input: readNotificationInput!): readNotificationPayload
  updateStatisticPreferences(input: updateStatisticPreferencesInput!): updateStatisticPreferencesPayload
  updateSportunityStatistic(input: updateSportunityStatisticsInput!): updateSportunityStatisticsPayload
  voteForManOfTheGame(input: voteForManOfTheGameInput!): voteForManOfTheGamePayload
  newStatisticFilter(input: newStatisticFilterInput!): newStatisticFilterPayload
  updateStatisticFilter(input: updateStatisticFilterInput!): updateStatisticFilterPayload
  removeStatisticFilter(input: removeStatisticFilterInput!): removeStatisticFilterPayload
  newSportunityTemplate(input: newSportunityTemplateInput!): newSportunityTemplatePayload
  updateSportunityTemplate(input: updateSportunityTemplateInput!): updateSportunityTemplatePayload
  removeSportunityTemplate(input: removeSportunityTemplateInput!): removeSportunityTemplatePayload
  newComposition(input: newCompositionInput!): newCompositionPayload
  updateComposition(input: updateCompositionInput!): updateCompositionPayload
  deleteComposition(input: deleteCompositionInput!): deleteCompositionPayload
  changeEventCompositions(input: updateSportunityCompositionsInput!): updateSportunityCompositionsPayload
  importNewUser(
    # The unique pseudo of the user
    pseudo: String!

    # FirstName of the user
    firstName: String

    # FirstName of the user
    lastName: String

    # The unique email of the user
    email: Email

    # The password of the user
    password: String

    # The gender of the user
    sex: Sex!

    # The type of user
    profileType: UserProfileType

    # Email of the parent / club
    superAccountEmail: String

    # Pseudo of the team, so this user is authorized to manage the team
    teamPseudo: String

    # Id of the sport the team practices
    sportId: String

    # Circle names to create for this user
    circleList: [String]
    externalReference: String
  ): User
  importNewSportunity(
    team1Pseudo: String!
    team1externalReference: String
    team2Pseudo: String!
    team2externalReference: String
    description: String!
    address: String!
    zip: Int
    city: String!
    country: String
    sport: String!
    price: Int!
    participantRangeMin: Int!
    participantRangeMax: Int!

    # The mode of the Sportunity
    mode: SportunityMode!

    # The kind of the Sportunity (private / public)
    kind: SportunityKind!

    # Beginning date of the sportunity
    beginning_date: String!

    # Ending date of the sportunity
    ending_date: String!
    team1Score: Int
    team2Score: Int
    externalReference: String
  ): Sportunity
  importUpdateSportunity(
    externalReference: String
    description: String!
    address: String!
    zip: Int
    city: String!
    country: String

    # Beginning date of the sportunity
    beginning_date: String!

    # Ending date of the sportunity
    ending_date: String!
    team1Score: Int
    team2Score: Int
  ): Sportunity
  testEmailTemplate(input: testEmailTemplateInput!): testEmailTemplatePayload

  # Fetches an object given its ID
  node(
    # The ID of an object
    id: ID!
  ): Node
}

input newAssistantTypeInput {
  # Sport type to create this event types
  sportType: SportTypeEnum!

  # The name of this event type
  name: StringTranslatedInput
  clientMutationId: String
}

type newAssistantTypePayload {
  assistantType: AssistantType
  viewer: Viewer
  clientMutationId: String
}

input newCarPoolingInput {
  # The ID of the sportunity to update
  sportunityID: String!

  # Car pooling input type
  carPooling: CarPoolingInput
  clientMutationId: String
}

type newCarPoolingPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

input newCircleInput {
  # A Circle input type
  circle: CircleInput
  clientMutationId: String
}

type newCirclePayload {
  edge: CircleEdge
  viewer: Viewer
  clientMutationId: String
}

input newCirclePaymentModelInput {
  paymentModel: CirclePaymentModelInput
  clientMutationId: String
}

type newCirclePaymentModelPayload {
  viewer: Viewer
  clientMutationId: String
}

input newCircleTermsOfUseInput {
  termsOfUse: CircleTermsOfUseInput
  clientMutationId: String
}

type newCircleTermsOfUsePayload {
  viewer: Viewer
  termsOfUse: CircleTermsOfUse
  clientMutationId: String
}

input newCompositionInput {
  # A User input type
  composition: CompositionInput
  clientMutationId: String
}

type newCompositionPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input newInfrastructureInput {
  venueId: String!
  infrastructure: InfrastructureInput
  clientMutationId: String
}

type newInfrastructurePayload {
  edge: VenueEdge
  viewer: Viewer
  clientMutationId: String
}

input newNotificationSubscriptionInput {
  clientSubscriptionId: String
}

type newNotificationSubscriptionPayload {
  edge: NotificationEdge
  viewer: Viewer
  clientSubscriptionId: String
}

input newOpponentSportunityInput {
  sportunityId: String!
  clientMutationId: String
}

type newOpponentSportunityPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

input newSlotInput {
  venueId: String!
  infrastructureId: String!
  slot: SlotInput
  repetitionNumber: Int
  clientMutationId: String
}

type newSlotPayload {
  edge: VenueEdge
  slot: Slot
  viewer: Viewer
  clientMutationId: String
}

input newSportInput {
  # a Sport input type
  sport: SportInput
  clientMutationId: String
}

type newSportPayload {
  edge: SportEdge
  viewer: Viewer
  clientMutationId: String
}

input newSportunityInput {
  # A Sportunity input type
  sportunity: SportunityInput
  clientMutationId: String
}

type newSportunityPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

input newSportunityTemplateInput {
  # A Sportunity template input type
  sportunityTemplate: SportunityTemplateInput
  clientMutationId: String
}

type newSportunityTemplatePayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input newSportunityTypeInput {
  # Sport type to create this event types
  sportType: SportTypeEnum!

  # The name of this event type
  name: StringTranslatedInput

  # Tells if a score can be set on this sportunity type
  isScoreRelevant: Boolean
  clientMutationId: String
}

type newSportunityTypePayload {
  sportunityType: SportunityType
  viewer: Viewer
  clientMutationId: String
}

input newSportunityTypeStatusInput {
  # Id of the sportunity type to create this status
  sportunityTypeID: String!

  # The name of this status
  name: StringTranslatedInput
  clientMutationId: String
}

type newSportunityTypeStatusPayload {
  sportunityTypeStatus: SportunityTypeStatus
  viewer: Viewer
  clientMutationId: String
}

input newStatisticFilterInput {
  # Name of the filter
  name: String!

  # Beginning date of the filter
  date_begin: String

  # Ending date of the filter
  date_end: String

  # List of circles of the filter
  circleList: [String]
  clientMutationId: String
}

type newStatisticFilterPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input newUserInput {
  # A User input type
  user: UserInput

  # Token of the super user creating this account
  superUserToken: String
  clientMutationId: String
}

type newUserPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input newVenueInput {
  # A Venue input type
  venue: VenueInput
  clientMutationId: String
}

type newVenuePayload {
  edge: VenueEdge
  viewer: Viewer
  clientMutationId: String
}

# An object with an ID
interface Node {
  # The id of the object.
  id: ID!
}

# Represents a notification
type Notification implements Node {
  # The ID of an object
  id: ID!

  # Title of the notification
  title: String

  # The content of the notification
  text: String!

  # The link of the notification when the user clicks on it
  link: String

  # Tells when the notification was created
  created: DateTime!

  # Image to show on list of notifications
  image: String

  # Type of notification
  notificationType: String

  # Tells if the notification is read or not
  isRead: Boolean
}

# A connection to a list of items.
type NotificationConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [NotificationEdge]

  # Total number of tags
  count: Int
}

# An edge in a connection.
type NotificationEdge {
  # The item at the end of the edge
  node: Notification

  # A cursor for use in pagination
  cursor: String!
}

# Represents a notification type input
input NotificationPreferenceInput {
  # Type of notification to send to invited users
  notification_type: SportunityNotificationPreference

  # If organizer wants to send the notification automatically x days before sportunity's beginning
  send_notification_x_days_before: Int
}

# Let the user choose if he wants to receive notifications
type NotificationPreferences {
  # Notification when user organizes a sportunity
  sportunityNewMainOrganizer: Boolean

  # Notification when user is a secondary organizer of a new sportunity
  sportunityNewSecondaryOrganizer: Boolean

  # Notification when user is a venue of a new sportunity
  sportunityNewVenueOrganizer: Boolean

  # Notification when user is invited to a new sportunity
  sportunityNewInvited: Boolean

  # Notification when a followed user creates a sportunity
  sportunityNewFollower: Boolean

  # Notification when organizer cancels his sportunity
  sportunityCancelMainOrganizer: Boolean

  # Notification when a sportunity where user is secondary organizer is cancelled
  sportunityCancelSecondaryOrganizer: Boolean

  # Notification when a sportunity where user is participant is cancelled
  sportunityCancelParticipant: Boolean

  # Notification when user books a sportunity
  sportunityBooked: Boolean

  # Notification when someone booked a sportunity where user is organizer
  sportunityBookedOrganizer: Boolean

  # Notification when someone cancelled is booking to a sportunity
  sportunityBookerCancel: Boolean

  # Notification when someone cancelled is booking to a sportunity where user is organizer
  sportunityBookerCancelOrganizer: Boolean

  # Notification when organizer modifies his sportunity
  sportunityModifiedMainOrganizer: Boolean

  # Notification when a sportunity where user is secondary organizer is modified
  sportunityModifiedSecondaryOrganizer: Boolean

  # Notification when a sportunity where user is venue is modified
  sportunityModifiedVenueOrganizer: Boolean

  # Notification when a sportuntiy were user is participant is modified
  sportunityModifiedParticipant: Boolean

  # Notification when participant's payment has been done
  paymentConfirmationOnDDay: Boolean

  # Notification for main organizer when he received a payment
  paymentReceivedMainOrganizer: Boolean

  # Notification for secondary organizer when he received a payment
  paymentReceivedSecondaryOrganizer: Boolean

  # Notification when user's certificate has been validated by admin user
  certificateValidated: Boolean

  # Notification to complete statistics
  sportunityCompleteStatistics: Boolean

  # Notification to vote for the man of the game
  sportunityVoteForManOfTheGame: Boolean
}

# Let the user choose if he wants to receive notifications
input NotificationPreferencesInput {
  # Notification when user organizes a sportunity
  sportunityNewMainOrganizer: Boolean

  # Notification when user is a secondary organizer of a new sportunity
  sportunityNewSecondaryOrganizer: Boolean

  # Notification when user is a venue of a new sportunity
  sportunityNewVenueOrganizer: Boolean

  # Notification when user is invited to a new sportunity
  sportunityNewInvited: Boolean

  # Notification when a followed user creates a sportunity
  sportunityNewFollower: Boolean

  # Notification when organizer cancels his sportunity
  sportunityCancelMainOrganizer: Boolean

  # Notification when a sportunity where user is secondary organizer is cancelled
  sportunityCancelSecondaryOrganizer: Boolean

  # Notification when a sportunity where user is participant is cancelled
  sportunityCancelParticipant: Boolean

  # Notification when user books a sportunity
  sportunityBooked: Boolean

  # Notification when someone booked a sportunity where user is organizer
  sportunityBookedOrganizer: Boolean

  # Notification when someone cancelled is booking to a sportunity
  sportunityBookerCancel: Boolean

  # Notification when someone cancelled is booking to a sportunity where user is organizer
  sportunityBookerCancelOrganizer: Boolean

  # Notification when organizer modifies his sportunity
  sportunityModifiedMainOrganizer: Boolean

  # Notification when a sportunity where user is secondary organizer is modified
  sportunityModifiedSecondaryOrganizer: Boolean

  # Notification when a sportunity where user is venue is modified
  sportunityModifiedVenueOrganizer: Boolean

  # Notification when a sportuntiy were user is participant is modified
  sportunityModifiedParticipant: Boolean

  # Notification when participant's payment has been done
  paymentConfirmationOnDDay: Boolean

  # Notification for main organizer when he received a payment
  paymentReceivedMainOrganizer: Boolean

  # Notification for secondary organizer when he received a payment
  paymentReceivedSecondaryOrganizer: Boolean

  # Notification when user's certificate has been validated by admin user
  certificateValidated: Boolean

  # Notification to complete statistics
  sportunityCompleteStatistics: Boolean

  # Notification to vote for the man of the game
  sportunityVoteForManOfTheGame: Boolean
}

# Represents a notification type input
input NotificationPreferenceUpdateInput {
  # Type of notification to send to invited users
  notification_type: SportunityNotificationPreference

  # If organizer wants to send the notification automatically x days before sportunity's beginning
  send_notification_x_days_before: Int
}

# Represent an organizer of a Sportunity
type Organizer implements Node {
  # The ID of an object
  id: ID!

  # Return a Users for a given id
  organizer: User

  # Tells if the given user is an administrator of this event
  isAdmin: Boolean!

  # Tells what is the role of this user in this event
  role: OrganizerRole!

  # Custom Role (if the role is not in our database)
  customRole: String

  # Get the Prices of an object
  price: Price

  # Get the type of asssistant profile for a sportunity
  secondaryOrganizerType: AssistantType

  # Custom Role (if the role is not in our database)
  customSecondaryOrganizerType: String
}

input organizerAddInvitedsInput {
  # The ID of the sportunity
  sportunityID: String!
  inviteds: [InvitedListToAdd]!

  # If needed, can put this invited list in a specific circle
  putInvitedsInCircle: String
  clientMutationId: String
}

type organizerAddInvitedsPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

input organizerAddParticipantsInput {
  # The ID of the sportunity
  sportunityID: String!
  participants: [ParticipantListToAdd]!

  # If needed, can put this participant list in a specific circle
  putParticipantsInCircle: String
  clientMutationId: String
}

type organizerAddParticipantsPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

# Represents an organizer input type
input OrganizerInput {
  organizer: String!

  # Tells if the organizer is administrator
  isAdmin: Boolean!

  # Tells the role of the organizer
  role: OrganizerRole!

  # The amount to give to this organizer
  price: PriceInput

  # Type id of secondary organizer
  secondaryOrganizerType: String

  # Custom Role (if the role is not in our database)
  customSecondaryOrganizerType: String
}

input organizerPickSurveyDateInput {
  # The ID of the sportunity to update
  sportunityID: String!

  # The beginning date of the choosen proposition
  beginning_date: String

  # The ending date of the choosen proposition
  ending_date: String
  clientMutationId: String
}

type organizerPickSurveyDatePayload {
  edge: SportunityEdge
  viewer: Viewer
  sportunity: Sportunity
  clientMutationId: String
}

# List of available roles an organizer can have on an event
enum OrganizerRole {
  # The organizer will coach participants
  COACH

  # The organizer will host the event
  VENUE
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String

  # When paginating forwards, the cursor to continue.
  endCursor: String
}

input ParticipantListToAdd {
  # The ID of the participant to add
  participantId: String

  # If the new participant doesn't exist, define a pseudo for him
  participantPseudo: String

  # If the new participant doesn't exist, his email
  participantEmail: String
}

# Payment method
type PaymentMethod implements Node {
  # The ID of an object
  id: ID!

  # CardRegistration Id to pass to mutation to complete registration
  cardType: String

  # A specific value to pass to the CardRegistrationURL
  cardMask: String

  # The expiry date of the card
  expirationDate: String
}

type PaymentModelConditionList {
  askedInformation: askedInformation

  # Comparator : ≤ ; < ; = ; > ; ≥
  askedInformationComparator: String

  # If asked information is number, number. If it's a boolean, 1 === true ; 0 === false
  askedInformationComparatorValue: Int

  # If asked information is date
  askedInformationComparatorDate: DateTime
}

input PaymentModelConditionListInput {
  # Id of the asked information
  askedInformation: String

  # Comparator : ≤ ; < ; = ; > ; ≥
  askedInformationComparator: String

  # If asked information is number, number. If it's a boolean, 1 === true ; 0 === false
  askedInformationComparatorValue: Int

  # If asked information is date
  askedInformationComparatorDate: String
}

# Status of event payments
enum PaymentStatus {
  # If user's card was verified & the sportunity will begin in more than 7 days
  Pending

  # If the sportunity begins in less than 7 days, the event price is locked on his card
  Locked

  # If the sportunity is passed, and the user paid it
  Done

  # If the sportunity is passed, and he payment failed
  Error

  # If user canceled and he has been replaced
  Canceled
}

# Represent an pending organizer of a Sportunity
type PendingOrganizer implements Node {
  # The ID of an object
  id: ID!

  # The list of all circles belonging to a given object
  circles(
    after: String
    first: Int
    before: String
    last: Int

    # Types of wanted circles
    type: [CircleTypeEnum]

    # Description of a filter in Sportunity
    filter: CirclesFilter
  ): CircleConnection

  # Tells if the given user is an administrator of this event
  isAdmin: Boolean!

  # Tells what is the role of this user in this event
  role: OrganizerRole!

  # Get the Prices of an object
  price: Price

  # Get the type of asssistant profile for a sportunity
  secondaryOrganizerType: AssistantType

  # Custom Role (if the role is not in our database)
  customSecondaryOrganizerType: String
}

# Represents a list of pending organizers input type
input PendingOrganizerInput {
  # If updating a pending organizer object
  id: String
  circles: [String]!

  # Tells if the organizer is administrator
  isAdmin: Boolean!

  # Tells the role of the organizer
  role: OrganizerRole!

  # The amount to give to this organizer
  price: PriceInput

  # Type id of secondary organizer
  secondaryOrganizerType: String

  # Custom Role (if the role is not in our database)
  customSecondaryOrganizerType: String
}

# Placeholders and their values
input Placeholders {
  # Ex: -link-
  placeholder: String

  # Ex: https://sportunity.com
  value: String
}

# A physical position
type PositionType {
  lat: Float
  lng: Float
}

# Represents a price
type Price {
  # The currency in which this price was set
  currency: Currency

  # The amount of specified currency
  #
  #         Important: The value is in cents to avoid Floating point error !!
  #         
  cents: Int!

  # Return a description: TranslatedString
  description: TranslatedString
}

# Prices for invited circles
type PriceForCircle {
  # A circle
  circle(
    # ID of the circle wanted
    id: ID
  ): Circle

  # Get the Prices of an object
  price: Price

  # Tells if members of the current circle should be participants by default (for free sportunities only)
  participantByDefault: Boolean

  # If participant by default = true, who should be excluded
  excludedParticipantByDefault: excludedParticipantByDefault

  # Who should be excluded from the invited list
  excludedInvitees: excludedInvitees
}

# Represents a price input type
input PriceInput {
  currency: Currency!

  # The amount of specified currency in cents
  cents: Int!
}

# Represents the preference of the organizer for privacy switching of the sportunity
input PrivacySwitchPreferenceInput {
  # Type of switch to change from private to public the sportunity
  privacy_switch_type: SportunityPrivacySwitchPreference

  # If organizer wants to switch the kind from private to public automatically x days before sportunity's beginning
  switch_privacy_x_days_before: Int
}

# Represents the preference of the organizer for privacy switching of the sportunity
type PrivacySwitchPreferenceOutput {
  # Type of switch to change from private to public the sportunity
  privacy_switch_type: SportunityPrivacySwitchPreference

  # If organizer wants to switch the kind from private to public automatically x days before sportunity's beginning
  switch_privacy_x_days_before: Int
}

# Represents the preference of the organizer for privacy switching of the sportunity
input PrivacySwitchPreferenceUpdateInput {
  # Type of switch to change from private to public the sportunity
  privacy_switch_type: SportunityPrivacySwitchPreference

  # If organizer wants to switch the kind from private to public automatically x days before sportunity's beginning
  switch_privacy_x_days_before: Int
}

type Query {
  viewer: Viewer

  # Fetches an object given its ID
  node(
    # The ID of an object
    id: ID!
  ): Node
}

input readChatInput {
  # The ID of the chat to read
  chatId: String
  clientMutationId: String
}

type readChatPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input readNotificationInput {
  notificationId: String!
  clientMutationId: String
}

type readNotificationPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input readNotificationsInput {
  clientMutationId: String
}

type readNotificationsPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input registerBankAccountInput {
  # The address of the owner of the bank account
  addressLine1: String!

  # The address of the owner of the bank account
  addressLine2: String

  # The city where lives the owner of the bank account
  city: String!

  # The postal code of the city where the owner of the bank account lives
  postalCode: String!

  # The country of the owner of the bank account
  country: String!

  # The name of the owner of the bank account
  ownerName: String!

  # The IBAN of the bank account
  IBAN: String!

  # The BIC of the bank account
  BIC: String
  clientMutationId: String
}

type registerBankAccountPayload {
  viewer: Viewer
  clientMutationId: String
}

input registerCardDataInput {
  # CardRegistration Id given by query in first place
  cardRegistrationId: String!

  # Having registered a card, this confirmation hash needs to be updated to the card item
  registrationData: String!
  clientMutationId: String
}

type registerCardDataPayload {
  paymentMethodId: String
  viewer: Viewer
  clientMutationId: String
}

input relaunchMembersForAskedInformationInput {
  circleId: String!
  clientMutationId: String
}

type relaunchMembersForAskedInformationPayload {
  edge: CircleEdge
  viewer: Viewer
  clientMutationId: String
}

input relaunchMembersForTermsOfUseValidationInput {
  termOfUsesId: String!
  clientMutationId: String
}

type relaunchMembersForTermsOfUseValidationPayload {
  edge: CircleEdge
  viewer: Viewer
  clientMutationId: String
}

input removeAssistantTypeInput {
  # ID of the assistant type to remove
  assistantTypeID: String!
  clientMutationId: String
}

type removeAssistantTypePayload {
  assistantType: AssistantType
  viewer: Viewer
  clientMutationId: String
}

input removeCircleMemberInput {
  circleId: String!
  userId: String
  pseudo: String
  email: String
  clientMutationId: String
}

type removeCircleMemberPayload {
  edge: CircleEdge
  viewer: Viewer
  clientMutationId: String
}

input removeCircleParentInput {
  circleId: String!
  userId: String!
  clientMutationId: String
}

type removeCircleParentPayload {
  edge: CircleEdge
  viewer: Viewer
  circle: Circle
  clientMutationId: String
}

input removeCircleTermsOfUseInput {
  # Id of the ToU to delete
  termsOfUseId: String!
  clientMutationId: String
}

type removeCircleTermsOfUsePayload {
  viewer: Viewer
  clientMutationId: String
}

input removeSecondaryOrganizerInput {
  # The IDs of the sportunities to update
  sportunityIDs: [String]!

  # Organizer input
  organizer: OrganizerInput!
  clientMutationId: String
}

type removeSecondaryOrganizerPayload {
  viewer: Viewer
  clientMutationId: String
}

input removeSportunityImageInput {
  # The ID of the sportunity to update
  sportunityID: String!

  # URL of the image to remove
  imageUrl: String!
  clientMutationId: String
}

type removeSportunityImagePayload {
  sportunity: Sportunity
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

input removeSportunityTemplateInput {
  # Id of the template to remove
  sportunityTemplateId: String!
  clientMutationId: String
}

type removeSportunityTemplatePayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input removeSportunityTypeInput {
  # ID of the sportunity type to remove
  sportunityTypeID: String!
  clientMutationId: String
}

type removeSportunityTypePayload {
  sportunityType: SportunityType
  viewer: Viewer
  clientMutationId: String
}

input removeSportunityTypeStatusInput {
  # ID of the sportunity type status to remove
  sportunityTypeStatusID: String!
  clientMutationId: String
}

type removeSportunityTypeStatusPayload {
  sportunityTypeStatus: SportunityTypeStatus
  viewer: Viewer
  clientMutationId: String
}

input removeStatisticFilterInput {
  # Id of the filter to remove
  statisticFilterId: String!
  clientMutationId: String
}

type removeStatisticFilterPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

# Represent a reporter user input type
type ReporterUser implements Node {
  # The ID of an object
  id: ID!

  # Return a Users for a given id
  user: User

  # Tells why the user has been reported
  reason: String
}

input reportUserInput {
  # The ID of the user to report
  userID: String

  # Reason of the report
  reason: String
  clientMutationId: String
}

type reportUserPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

# Save a circle filter
input SavedCircleFilterInput {
  # Id of the filter
  userCircleFilterId: String

  # Name of the filter
  filterName: String

  # Filter by location constraint
  location: LocationConstraint

  # Filter by sport name and level constraint
  sport: [SportConstraint]

  # List of circles
  circleType: [CircleListTypeEnum]

  # The type of the members
  memberType: CircleTypeEnum

  # Types of circle
  memberTypes: [CircleTypeEnum]

  # Modes (private, public)
  modes: [CircleKind]

  # Filter by owners
  owners: [String]

  # The position of this filter in the list
  position: Int
}

# Represents the score of the current sportunity
type Score {
  # Score of the current team
  currentTeam: Int

  # Score of the adversary team
  adversaryTeam: Int
}

# Represents the score of the current sportunity
input ScoreInput {
  # Score of the current team
  currentTeam: Int

  # Score of the adversary team
  adversaryTeam: Int
}

input secondaryOrganizerCancelRoleInput {
  # The ID of the sportunity to update
  sportunityID: String!

  # Tells if the user wants to cancel his co-organization to the serie
  cancelSerie: Boolean
  clientMutationId: String
}

type secondaryOrganizerCancelRolePayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

input secondaryOrganizerPickRoleInput {
  # The ID of the sportunity to update
  sportunityID: String!

  # The ID of the pending Organizer object
  pendingOrganizerID: String!
  clientMutationId: String
}

type secondaryOrganizerPickRolePayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

input secondaryOrganizerRefuseRoleInput {
  # The ID of the sportunity to update
  sportunityID: String!

  # The ID of the pending Organizer object
  pendingOrganizerID: String!
  clientMutationId: String
}

type secondaryOrganizerRefuseRolePayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

# Informations on the serie
type serie_information {
  firstDate: DateTime
  lastDate: DateTime
  remainingSlots: Int
}

input setDefaultCircleFilterInput {
  # ID of the filter to set as default
  filterID: String
  clientMutationId: String
}

type setDefaultCircleFilterPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input setDefaultFilterInput {
  # ID of the filter to set as default
  filterID: String
  clientMutationId: String
}

type setDefaultFilterPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

# User's gender
enum Sex {
  # Male user
  MALE

  # Female user
  FEMALE

  # Unknown gender, or companies
  OTHER
}

# Gender restriction on events
enum SexRestriction {
  # Only males are allowed
  MALE

  # Only females are allowed
  FEMALE

  # No restrictions on sex
  NONE
}

# An open access time slot
type Slot implements Node {
  # The ID of an object
  id: ID!
  venue: Venue
  infrastructure: Infrastructure

  # The time the slot starts
  from: DateTime!

  # The time the slot ends
  end: DateTime!

  # Get the Prices of an object
  price: Price

  # Return a bunch of Users for a given array of id
  usersSlotIsFor: [User]

  # The list of all circles belonging to a given object
  circlesSlotIsFor(
    after: String
    first: Int
    before: String
    last: Int

    # Types of wanted circles
    type: [CircleTypeEnum]

    # Description of a filter in Sportunity
    filter: CirclesFilter
  ): CircleConnection

  # Tells if the current slot is flexible or not
  flexible: Boolean

  # A Sportunity
  sportunity(
    # ID of the sportunity wanted
    id: ID
  ): Sportunity

  # Get the slot status
  status: SlotStatus

  # Return a Users for a given id
  user_creating: User

  # Tells if current slot is part of a serie
  is_repeated: Boolean

  # Occurence number if the slot is in a serie
  is_repeated_occurence_number: Int

  # Number of occurences in the serie if the actual slot is in a serie
  number_of_occurences: Int
  serie_information: serie_information
}

# Represents a slot input type
input SlotInput {
  # The slot id to update (if needed)
  id: String
  from: String!

  # The time the slot ends
  end: String!

  # The price of the slot
  price: PriceInput

  # Id of the users this slot is made for
  usersSlotIsFor: [String]

  # Id of the circles this slot is made for
  circlesSlotIsFor: [String]

  # Tells if the current slot is flexible or not
  flexible: Boolean
}

# A slot status
enum SlotStatus {
  # Nothing on this slot
  PENDING

  # A Sportunity is planned on this 
  PLANNED

  # A past slot
  PAST

  # A slot with a cancelled sportunity
  CANCELLED
}

# A Sportunity Sport
type Sport implements Node {
  # The ID of an object
  id: ID!

  # Return a name: TranslatedString
  name: TranslatedString

  # The logo for this sport in SVG format
  logo: String!

  # Return a positions: TranslatedString
  positions: [TranslatedString]

  # Return the certificates of a given object
  certificates: [Certificate]

  # Return a levels: TranslatedSportLevel
  levels: [Translated]

  # Tells if the sport is active or not
  status: status

  # Type of this sport
  type: SportTypeEnum

  # Get the available types of events for a sport
  sportunityTypes(
    # Sport type to get the event types possible
    sportType: SportTypeEnum
  ): [SportunityType]

  # Get the available types of asssistant profile for a sport
  assistantTypes(
    # Sport type to get the event types possible
    sportType: SportTypeEnum
  ): [AssistantType]

  # Images of the field
  fieldImages: [String]
}

# A connection to a list of items.
type SportConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [SportEdge]

  # Total number of tags
  count: Int
}

# Represents a sport constraint
input SportConstraint {
  # The id of the sport
  sportID: String

  # The levels ids
  level: [String]
}

# The level of a user for a given sport
type SportDescriptor {
  # Get a sport for object that have only one
  sport(
    # ID of the sport wanted
    id: ID
  ): Sport

  # Return a levels: TranslatedSportLevel
  levels: [Translated]

  # Return the certificates descriptor
  certificates: [CertificateDescriptor]

  # Return a positions: TranslatedString
  positions: [TranslatedString]

  # Get the available types of asssistant profile for a sport
  assistantType(
    # Sport type to get the event types possible
    sportType: SportTypeEnum
  ): [AssistantType]
}

# Represents a sport descriptor input
input SportDescriptorInput {
  # Id of the sport
  sport: String!

  # Ids of the levels
  levels: [String]

  # List of certificates the user has
  certificates: [CertificateDescriptorInput]

  # The positions the user plays in the sport
  positions: [String]

  # The assistants the user can be
  assistantType: [String]
}

# An edge in a connection.
type SportEdge {
  # The item at the end of the edge
  node: Sport

  # A cursor for use in pagination
  cursor: String!
}

# Allow you to control which results are returned
input SportFilter {
  # Name or part of the name of the searched sport
  name: String

  # Language of the sport's name searched
  language: SupportedLanguage!
}

# Represents a sport input type
input SportInput {
  # The name of the sport in different langauges
  name: StringTranslatedInput!

  # The logo for this sport in SVG format
  logo: String!

  # The list of postions in different langauges
  positions: [StringTranslatedInput]

  # The list of certicates
  certificates: [CertificateInput]

  # The list of the levels in different langauges
  levels: [SportLevelInputTranslatedInput]

  # Type of this sport
  type: SportTypeEnum

  # Images of the field
  fieldImages: [String]
}

# A skill level for a given sport
type SportLevel {
  # The name of the sport level in a language
  name: String

  # The description of a sport level in a language
  description: String

  # The absolute skill score associated to this level
  #
  #         This is used to compare sport level in different coutries
  skillLevel: Int!
}

# Represents a sport level input type
input SportLevelInput {
  # The name of the sport level in a language
  name: String

  # The description of a sport level in a language
  description: String

  # The absolute skill score associated to this level
  #
  #       This is used to compare sport level in different coutries
  skillLevel: Int!
}

# Represent a translated SportLevelInput
input SportLevelInputTranslatedInput {
  FR: SportLevelInput
  EN: SportLevelInput
  DE: SportLevelInput
  ES: SportLevelInput
}

# Specifies which type of sport it is
enum SportTypeEnum {
  # A team vs another
  COLLECTIVE

  # Combat sports
  COMBAT

  # Racket sports
  RACKETSPORT

  # Other sports
  OTHER
}

enum Sportunities_Order {
  BEGINNING_DATE_ASC
  BEGINNING_DATE_DESC
  CREATION_DATE_ASC
  CREATION_DATE_DESC
}

enum SportunitiesOrganizers_Order {
  BEGINNING_DATE_ASC
  BEGINNING_DATE_DESC
  CREATION_DATE_ASC
  CREATION_DATE_DESC
}

# Statistics for an organizer
type SportunitiesStatisticsOrganizer {
  # Get the sportunity type
  sportunityType: SportunityType

  # Get the sportunity type status
  sportunityTypeStatus: SportunityTypeStatus

  # Value of the statistic
  value: Int
  details: [StatisticDetails]
}

# A sportunity (Event)
type Sportunity implements Node {
  # The ID of an object
  id: ID!

  # The title of the sportunity
  title: String!

  # The description of the Sportunity
  description: String!

  # The address of a user
  address: AddressModel

  # Get a venue for object that have only one
  venue(
    # ID of the sportunity wanted
    id: ID
  ): Venue

  # Get the infrastructure of an object
  infrastructure(
    # ID of the infrastructure wanted
    id: ID
  ): Infrastructure

  # A slot
  slot(
    # ID of the slot we want
    id: ID
  ): Slot

  # Get the list of organizers
  organizers: [Organizer]

  # Get the list of pending organizers
  pendingOrganizers: [PendingOrganizer]

  # The number of share this Sportunity has
  nbShares: Int

  # Return a bunch of Users for a given array of id
  participants: [User]
  canceling: [Canceling]

  # Return a bunch of Users for a given array of id
  waiting: [User]

  # Return a bunch of Users for a given array of id
  willing: [User]
  invited: [Invited]

  # Get the Prices of an object
  price: Price

  # Return a participantRange: NumberInterval
  participantRange: IntInterval

  # The policy applied to know who is alloed to go to the waiting list
  mode: SportunityMode!

  # The kind of the Sportunity (private / public)
  kind: SportunityKind!

  # Images of the event
  images: [String]

  # The date when users in the willing list will move to the
  #       waiting list if we are in RANDOM mode
  randomDate: DateTime

  # Return a ageRestriction: NumberInterval
  ageRestriction: IntInterval

  # The restriction on sex to participate to the event
  sexRestriction: SexRestriction

  # The sport information for a sportunity
  sport: SportunitySport

  # Beginning date of the sportunity
  beginning_date: DateTime!

  # Ending date of the sportunity
  ending_date: DateTime!
  survey: Survey

  # Sportunity cancelling date
  cancel_date: DateTime

  # Get the status of the sportunity for current User
  status(
    # ID of the sportunity wanted
    sportunityId: String

    # ID of the user to get his status
    userId: String
  ): String

  # Get the status of payments for sportunity
  paymentStatus: [SportunityPaymentStatus]

  # Fees to apply to organizers of this sportunity
  fees: Int
  creation_status: SportunityCreationStatus

  # Date of creation of the sportunity
  creation_date: DateTime

  # The list of all circles belonging to a given object
  invited_circles(
    after: String
    first: Int
    before: String
    last: Int

    # Types of wanted circles
    type: [CircleTypeEnum]

    # Description of a filter in Sportunity
    filter: CirclesFilter
  ): CircleConnection
  price_for_circle: [PriceForCircle]
  notification_preference: SportunityNotificationPreferenceOutput

  # Preference of privacy switch
  privacy_switch_preference: PrivacySwitchPreferenceOutput

  # Occurence number if the sportunity is in a serie
  is_repeated_occurence_number: Int

  # Number of occurences in the serie if the actual sportunity is in a serie
  number_of_occurences: Int

  # Set to true if organizer doesn't want to show the sportunity's participant list
  hide_participant_list: Boolean

  # Get the sportunity type
  sportunityType: SportunityType

  # Get the sportunity type status
  sportunityTypeStatus: SportunityTypeStatus

  # Score of this sportunity
  score: Score

  # Return a boolean to tell if current user can vote
  canUserVoteForManOfTheGame: Boolean
  manOfTheGameVotes: [manOfTheGameVotes]

  # Return the car-poolings of a given sportunity
  carPoolings: [CarPooling]
  game_information: GameInformation

  # Get the Compositions of a user / event
  compositions: [CompositionOutput]
}

# A connection to a list of items.
type SportunityConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [SportunityEdge]

  # Total number of tags
  count: Int
}

# Creation status of this sportunity
type SportunityCreationStatus {
  # The status of current sportunity
  status: ValidationStatus

  # Tells the reason of the current status
  reason: String
}

# An edge in a connection.
type SportunityEdge {
  # The item at the end of the edge
  node: Sportunity

  # A cursor for use in pagination
  cursor: String!
}

# Represents a sportunity input type
input SportunityInput {
  # The title of the Sportunity
  title: String!

  # The description of the Sportunity
  description: String!

  # The address of the Sportunity
  address: AddressInput

  # The venue id of the Sportunity
  venue: String

  # The infrastructure id
  infrastructure: String

  # The slot id
  slot: String
  organizers: [OrganizerInput]!

  # List of pending organizers
  pendingOrganizers: [PendingOrganizerInput]

  # Payment method id of main organizer to pay secondary organizers
  secondaryOrganizersPaymentMethod: String

  # If main organizer wants to pay secondary organizers with his wallet
  secondaryOrganizersPaymentByWallet: Boolean

  # Selected sport, levels, positions and certificates
  sport: SportunitySportInput!

  # Number of times the sportunity has been shared
  nbShares: Int

  # The price of the Sportunity
  price: PriceInput

  # The participant range accepted for the Sportunity
  participantRange: IntIntervalInput!

  # If the organizer want to participate to the sportunity
  participants: ID

  # The mode of the Sportunity
  mode: SportunityMode!

  # The kind of the Sportunity (private / public)
  kind: SportunityKind!

  # The date when user in willing pass to waiting
  randomDate: String

  # The age interval allowed for the Sportunity
  ageRestriction: IntIntervalInput!

  # The sex restriction fro the Sportunity
  sexRestriction: SexRestriction

  # Beginning date of the sportunity
  beginning_date: String!

  # Ending date of the sportunity
  ending_date: String!

  # List of dates for a survey
  survey_dates: [SurveyDatesInput]

  # Sportunity's cancelling date
  cancel_date: String

  # Users who are invited to participate
  invited: [InvitedInput]

  # List of circles invited to join the sportunity
  invited_circles: [String]

  # Prices of the different invited circles
  price_for_circle: [InvitedCircleInput]

  # The card Id for a participant to pay
  paymentMethodId: ID

  # The number of times this sportunity will be repeated
  repeat: Int

  # Set to true if organizer doesn't want to show the sportunity's participant list
  hide_participant_list: Boolean

  # Preference of notification type to send to invited users
  notification_preference: NotificationPreferenceInput

  # Preference of privacy switch
  privacy_switch_preference: PrivacySwitchPreferenceInput

  # Type of the event (regarding its sport)
  sportunityType: String

  # Information of the game : opponent, season, ... 
  game_information: GameInformationInput
}

# Specifies which kind of sportunity it is
enum SportunityKind {
  # The sportuniy is public means that everyone can see it
  PUBLIC

  # The sportunity is private, only invited users can see it 
  PRIVATE
}

enum SportunityMode {
  # Everyone goes automatically to the waiting list and can pay now
  FCFS

  # Everyone goes to willing list and users will be moved to the waiting
  #         list at given time by a bot
  RANDOM

  # Everyone goes to willing list and users will be moved to the waiting
  #         list by an organizer
  ORGANIZER_PICK
}

enum SportunityNotificationPreference {
  # Send the notification to invited users as soon as the sportunity is created.
  Now

  # Send the notification to invited users only when organizer asks for it.
  Manually

  # Send the notification to invited users a few days (default 8 days) before sportunity's beginning.
  Automatically
}

# Preference of notification type to send to invited users
type SportunityNotificationPreferenceOutput {
  # Type of notification to send to invited users
  notification_type: SportunityNotificationPreference

  # If organizer wants to send the notification automatically x days before sportunity's beginning
  send_notification_x_days_before: Int

  # Date of last notification post
  last_post: DateTime
}

# Opponent of this game
input SportunityOpponentInput {
  # Id of the opponent organizer
  organizer: String

  # Email of the opponent organizer if he is not in our database
  organizerEmail: String

  # Pseudo of the opponent organizer if he is not in our database
  organizerPseudo: String

  # Id of the opponent sportunity
  event: String

  # Tells if the organizer is looking for an opponent
  lookingForAnOpponent: Boolean

  # Tells if the organizer doesn't know the opponent
  unknownOpponent: Boolean

  # List of circles that can create a match against current sportunity
  invitedOpponents: [String]
}

# Opponent of this game
type SportunityOpponentOutput {
  # Return a Users for a given id
  organizer: User

  # Pseudo of the opponent if he is not in our database
  organizerPseudo: String

  # A Sportunity
  event(
    # ID of the sportunity wanted
    id: ID
  ): Sportunity

  # Tells if the organizer is looking for an opponent
  lookingForAnOpponent: Boolean

  # Tells if the organizer doesn't know the opponent
  unknownOpponent: Boolean

  # The list of all circles belonging to a given object
  invitedOpponents(
    after: String
    first: Int
    before: String
    last: Int

    # Types of wanted circles
    type: [CircleTypeEnum]

    # Description of a filter in Sportunity
    filter: CirclesFilter
  ): CircleConnection
}

# Opponent of this game
input SportunityOpponentUpdateInput {
  # Id of the opponent organizer
  organizer: String

  # Email of the opponent organizer if he is not in our database
  organizerEmail: String

  # Pseudo of the opponent organizer if he is not in our database
  organizerPseudo: String

  # Id of the opponent sportunity
  event: String

  # Tells if the organizer is looking for an opponent
  lookingForAnOpponent: Boolean

  # Tells if the organizer doesn't know the opponent
  unknownOpponent: Boolean

  # List of circles that can create a match against current sportunity
  invitedOpponents: [String]
}

# status of the payment of sportunity for User
type SportunityPaymentStatus implements Node {
  # The ID of an object
  id: ID!

  # Return a Users for a given id
  user: User

  # Sportunity Payment Status
  status: PaymentStatus

  # Get the Prices of an object
  price: Price

  # Tells if the user wants to pay with his wallet
  paymentWithWallet: Boolean

  # The payment method the user choose for an event
  paymentMethod: PaymentMethod

  # Last update date
  updated: DateTime
}

enum SportunityPrivacySwitchPreference {
  # The organizer can manually change the privacy of the sportunity
  Manually

  # Kind of the sportunity will be changed automatically some days before sportunity begins
  Automatically
}

# The sport information for a sportunity
type SportunitySport {
  # Get a sport for object that have only one
  sport(
    # ID of the sport wanted
    id: ID
  ): Sport

  # Tells if all the sport's levels have been selected
  allLevelSelected: Boolean

  # Return a levels: TranslatedSportLevel
  levels: [Translated]

  # Return the certificates of a given object
  certificates: [Certificate]

  # Return a positions: TranslatedString
  positions: [TranslatedString]
}

# Represents a sportunity's sport input
input SportunitySportInput {
  # Id of the sport
  sport: String!

  # Tells if all the sport's levels have been selected
  allLevelSelected: Boolean

  # Ids of the levels
  levels: [String]

  # List of certificates
  certificates: [String]

  # The positions the user plays in the sport
  positions: [String]
}

# Represents a sportunity statistic input type
input SportunityStatisticInput {
  # Id of the statistic preference linked to this statistic
  statisticId: String

  # Id of the participant (null if the statistic if for the sportunity)
  participantId: String

  # Value of the current statistic
  value: Int
}

# Status of an event, for the current user
enum SportunityStatus {
  # Filter available sportunities
  Available

  # Filter booked sportunities
  Booked

  # Filter organized sportunities
  Organized

  # Filter organized and booked sportunities
  MySportunities

  # Filter sporunities where user is invited
  Invited

  # Filter sportunities where user was invited but declined
  Declined

  # Filter past sportunities
  Past

  # Filter cancelled sportunities
  Cancelled

  # Filter co-organizer sportunities
  CoOrganizer

  # Filter asked co-organizer sportunities
  AskedCoOrganizer

  # Filter for surveys
  Survey
}

# Represents a sportunity status input type
input SportunityStatusInput {
  # The current status of the sportunity
  status: ValidationStatus

  # The reason of current status
  reason: String
}

# A sportunity template
type SportunityTemplate implements Node {
  # The ID of an object
  id: ID!

  # The title of the sportunity
  title: String

  # The description of the Sportunity
  description: String

  # The address of a user
  address: AddressModel

  # Get the list of organizers
  organizers: [Organizer]

  # Get the list of pending organizers
  pendingOrganizers: [PendingOrganizer]
  invited: [SportunityTemplateInvited]

  # Get the Prices of an object
  price: Price

  # Return a participantRange: NumberInterval
  participantRange: IntInterval

  # The policy applied to know who is alloed to go to the waiting list
  mode: SportunityMode!

  # The kind of the Sportunity (private / public)
  kind: SportunityKind!

  # Images of the event
  images: [String]

  # Return a ageRestriction: NumberInterval
  ageRestriction: IntInterval

  # The restriction on sex to participate to the event
  sexRestriction: SexRestriction

  # The sport information for a sportunity
  sport: SportunitySport

  # Fees to apply to organizers of this sportunity
  fees: Int

  # Date of creation of the sportunity
  creation_date: DateTime

  # The list of all circles belonging to a given object
  invited_circles(
    after: String
    first: Int
    before: String
    last: Int

    # Types of wanted circles
    type: [CircleTypeEnum]

    # Description of a filter in Sportunity
    filter: CirclesFilter
  ): CircleConnection
  price_for_circle: [SportunityTemplatePriceForCircle]
  notification_preference: SportunityTemplateNotificationPreferenceOutput

  # Preference of privacy switch
  privacy_switch_preference: SportunityTemplatePrivacySwitchPreferenceOutput

  # Occurence number if the sportunity is in a serie
  is_repeated_occurence_number: Int

  # Number of occurences in the serie if the actual sportunity is in a serie
  number_of_occurences: Int

  # Set to true if organizer doesn't want to show the sportunity's participant list
  hide_participant_list: Boolean

  # Get the sportunity type
  sportunityType: SportunityType
  game_information: SportunityTemplateGameInformation
}

# Who should be excluded from the invited list
type SportunityTemplateExcludedInvitees {
  # Statuses of members to exclude
  excludedStatus: [CircleMemberStatus]

  # Return a bunch of Users for a given array of id
  excludedMembers: [User]

  # Should this event invite parents
  excludeParents: Boolean
}

# If participant by default = true, who should be excluded
type SportunityTemplateExcludedParticipantByDefault {
  # Statuses of members to exclude
  excludedStatus: [CircleMemberStatus]

  # Return a bunch of Users for a given array of id
  excludedMembers: [User]

  # Should this event include parents as participant by default
  excludeParents: Boolean
}

# Information of the game : opponent, season, ... 
type SportunityTemplateGameInformation {
  # Information about the opponent
  opponent: SportunityTemplateOpponentOutput
}

# Information of the game : opponent, season, ... 
input SportunityTemplateGameInformationInput {
  # Information about the opponent
  opponent: SportunityTemplateOpponentInput
}

# Represents a sportunity input type
input SportunityTemplateInput {
  # The title of the Sportunity
  title: String!

  # The description of the Sportunity
  description: String!

  # The address of the Sportunity
  address: AddressInput

  # The organizers of the Sportunity
  organizers: [OrganizerInput]!

  # List of pending organizers
  pendingOrganizers: [PendingOrganizerInput]

  # Payment method id of main organizer to pay secondary organizers
  secondaryOrganizersPaymentMethod: String

  # If main organizer wants to pay secondary organizers with his wallet
  secondaryOrganizersPaymentByWallet: Boolean

  # Selected sport, levels, positions and certificates
  sport: SportunitySportInput!

  # The price of the Sportunity
  price: PriceInput

  # The participant range accepted for the Sportunity
  participantRange: IntIntervalInput!

  # The mode of the Sportunity
  mode: SportunityMode!

  # The kind of the Sportunity (private / public)
  kind: SportunityKind!

  # The age interval allowed for the Sportunity
  ageRestriction: IntIntervalInput!

  # The sex restriction fro the Sportunity
  sexRestriction: SexRestriction

  # Users who are invited to participate
  invited: [InvitedInput]

  # List of circles invited to join the sportunity
  invited_circles: [String]

  # Prices of the different invited circles
  price_for_circle: [InvitedCircleInput]

  # Set to true if organizer doesn't want to show the sportunity's participant list
  hide_participant_list: Boolean

  # Preference of notification type to send to invited users
  notification_preference: SportunityTemplateNotificationPreferenceInput

  # Preference of privacy switch
  privacy_switch_preference: SportunityTemplatePrivacySwitchPreferenceInput

  # Type of the event (regarding its sport)
  sportunityType: String

  # Information of the game : opponent, season, ... 
  game_information: SportunityTemplateGameInformationInput
}

# Represent a user invited to a Sportunity
type SportunityTemplateInvited {
  # Return a Users for a given id
  user: User

  # Tells the answer of the invited user
  answer: invitedUserAnswer
}

# Represents a notification type input
input SportunityTemplateNotificationPreferenceInput {
  # Type of notification to send to invited users
  notification_type: SportunityNotificationPreference

  # If organizer wants to send the notification automatically x days before sportunity's beginning
  send_notification_x_days_before: Int
}

# Preference of notification type to send to invited users
type SportunityTemplateNotificationPreferenceOutput {
  # Type of notification to send to invited users
  notification_type: SportunityNotificationPreference

  # If organizer wants to send the notification automatically x days before sportunity's beginning
  send_notification_x_days_before: Int

  # Date of last notification post
  last_post: DateTime
}

# Opponent of this game
input SportunityTemplateOpponentInput {
  # Id of the opponent organizer
  organizer: String

  # Email of the opponent organizer if he is not in our database
  organizerEmail: String

  # Pseudo of the opponent organizer if he is not in our database
  organizerPseudo: String

  # Id of the opponent sportunity
  event: String

  # Tells if the organizer is looking for an opponent
  lookingForAnOpponent: Boolean

  # Tells if the organizer doesn't know the opponent
  unknownOpponent: Boolean

  # List of circles that can create a match against current sportunity
  invitedOpponents: [String]
}

# Opponent of this game
type SportunityTemplateOpponentOutput {
  # Return a Users for a given id
  organizer: User

  # Pseudo of the opponent if he is not in our database
  organizerPseudo: String

  # Tells if the organizer is looking for an opponent
  lookingForAnOpponent: Boolean

  # Tells if the organizer doesn't know the opponent
  unknownOpponent: Boolean

  # The list of all circles belonging to a given object
  invitedOpponents(
    after: String
    first: Int
    before: String
    last: Int

    # Types of wanted circles
    type: [CircleTypeEnum]

    # Description of a filter in Sportunity
    filter: CirclesFilter
  ): CircleConnection
}

# Prices for invited circles
type SportunityTemplatePriceForCircle {
  # A circle
  circle(
    # ID of the circle wanted
    id: ID
  ): Circle

  # Get the Prices of an object
  price: Price

  # Tells if members of the current circle should be participants by default (for free sportunities only)
  participantByDefault: Boolean

  # If participant by default = true, who should be excluded
  excludedParticipantByDefault: SportunityTemplateExcludedParticipantByDefault

  # Who should be excluded from the invited list
  excludedInvitees: SportunityTemplateExcludedInvitees
}

# Represents the preference of the organizer for privacy switching of the sportunity
input SportunityTemplatePrivacySwitchPreferenceInput {
  # Type of switch to change from private to public the sportunity
  privacy_switch_type: SportunityPrivacySwitchPreference

  # If organizer wants to switch the kind from private to public automatically x days before sportunity's beginning
  switch_privacy_x_days_before: Int
}

# Represents the preference of the organizer for privacy switching of the sportunity
type SportunityTemplatePrivacySwitchPreferenceOutput {
  # Type of switch to change from private to public the sportunity
  privacy_switch_type: SportunityPrivacySwitchPreference

  # If organizer wants to switch the kind from private to public automatically x days before sportunity's beginning
  switch_privacy_x_days_before: Int
}

# An event type, regarding its sport
type SportunityType implements Node {
  # The ID of an object
  id: ID!

  # Return a name: TranslatedString
  name: TranslatedString

  # Get the available status for a type of event for a sport
  statuses: [SportunityTypeStatus]

  # Tells if a score can be set on this sportunity type
  isScoreRelevant: Boolean
}

# An event type status, regarding its sport
type SportunityTypeStatus implements Node {
  # The ID of an object
  id: ID!

  # Return a name: TranslatedString
  name: TranslatedString
}

# Represents a sportunity input type
input SportunityUpdateInput {
  # The title of the Sportunity
  title: String

  # The description of the Sportunity
  description: String

  # The address of the Sportunity
  address: AddressInput

  # The venue id of the Sportunity
  venue: String

  # The infrastructure id
  infrastructure: String

  # The slot id
  slot: String
  organizers: [OrganizerInput]

  # List of pending organizers
  pendingOrganizers: [PendingOrganizerInput]

  # Payment method id of main organizer to pay secondary organizers
  secondaryOrganizersPaymentMethod: String

  # If main organizer wants to pay secondary organizers with his wallet
  secondaryOrganizersPaymentByWallet: Boolean

  # Selected sport, levels, positions and certificates
  sport: SportunitySportInput

  # Number of times the sportunity has been shared
  nbShares: Int

  # The price of the Sportunity
  price: PriceInput

  # The participant range accepted for the Sportunity
  participantRange: IntIntervalInput

  # The mode of the Sportunity
  mode: SportunityMode

  # The kind of the Sportunity (private / public)
  kind: SportunityKind

  # The date when user in willing pass to waiting
  randomDate: String

  # The age interval allowed for the Sportunity
  ageRestriction: IntIntervalInput

  # The sex restriction fro the Sportunity
  sexRestriction: SexRestriction

  # Beginning date of the sportunity
  beginning_date: String

  # Ending date of the sportunity
  ending_date: String

  # List of dates for a survey
  survey_dates: [SurveyDatesUpdateInput]

  # Sportunity's cancelling date
  cancel_date: String

  # Fees to apply to organizers of this sportunity
  fees: Int

  # Users who are going to participate
  participants: ID

  # Users who wants to cancel his booking
  canceling: ID

  # Cancelation reason -> id of the stat
  canceling_reason: ID

  # Users who are invited to participate
  invited: [InvitedInput]

  # List of circle Ids invited to join the sportunity
  invited_circles: [String]

  # Prices of the different invited circles
  price_for_circle: [InvitedCircleInput]

  # The status of current venue
  creation_status: SportunityStatusInput

  # The card Id for a participant to pay
  paymentMethodId: ID

  # Tells if the booker wants to pay with his wallet
  paymentByWallet: Boolean

  # Preference of notification type to send to invited users
  notification_preference: NotificationPreferenceUpdateInput

  # Preference of privacy switch
  privacy_switch_preference: PrivacySwitchPreferenceUpdateInput

  # Tells if repeated sportunities must be modified too
  modifyRepeatedSportunities: Boolean

  # Set to true if organizer doesn't want to show the sportunity's participant list
  hide_participant_list: Boolean

  # Type of the event (regarding its sport)
  sportunityType: String

  # Status of the event (regarding its sportunityType)
  sportunityTypeStatus: String

  # Score of this sportunity
  score: ScoreInput

  # Information of the game : opponent, season, ... 
  game_information: GameInformationUpdateInput
}

# Represents a sport input type
input SportUpdateInput {
  # The name of the sport in different langauges
  name: StringTranslatedInput

  # The logo for this sport in SVG format
  logo: String

  # The list of postions in different langauges
  positions: [StringTranslatedInput]

  # The list of certicates
  certificates: [CertificateInput]

  # The list of the levels in different langauges
  levels: [SportLevelInputTranslatedInput]

  # Tells if the sport is active or not
  status: status

  # Type of this sport
  type: SportTypeEnum

  # Images of the field
  fieldImages: [String]
}

# Statistic
type Statistic {
  # Get the current statistic
  statisticName: StatisticName

  # A Sportunity
  sportunity(
    # ID of the sportunity wanted
    id: ID
  ): Sportunity

  # Return a Users for a given id
  participant: User

  # Value of the statistic
  value: Int

  # Tells if the current stat is about availability
  isAvailabilityStat: Boolean
}

# Creation status of this sportunity
type StatisticDetails {
  # Return a Users for a given id
  opponent: User

  # Value of this stat for opponent
  value: Int
}

# Statistic filter
type StatisticFilter {
  # The ID of an object
  id: ID!

  # Name of the statistic filter
  name: String

  # Beginning date of the filter
  date_begin: DateTime

  # Ending date of the filter
  date_end: DateTime

  # The list of all circles belonging to a given object
  circleList(
    after: String
    first: Int
    before: String
    last: Int

    # Types of wanted circles
    type: [CircleTypeEnum]

    # Description of a filter in Sportunity
    filter: CirclesFilter
  ): CircleConnection
}

# Statistic name
type StatisticName {
  # The ID of an object
  id: ID!

  # Name of the statistic
  name: String
}

# Statistic preferences for the current user
type StatisticPreferences {
  # Tells if the user's stats are private or public
  private: Boolean

  # Tells if the user activated man of the game statistics
  isManOfTheGameActivated: Boolean
  userStats: userStats
  availabilityStats: availabilityStats
}

# Represents a statistic preferences input type
input StatisticPreferencesInput {
  # Defines if those statistics are private or public
  private: Boolean

  # Tells if the user activated man of the game statistics
  isManOfTheGameActivated: Boolean

  # Represent a user's preference for his participant's stats
  userStats: UserStatsPrefsInput

  # Represent a user's preference for his participant's availability
  availabilityStats: UserAvailabilityStatsPrefsInput
}

# List of available status for sports
enum status {
  # The sport is valid, users can see it
  ACTIVE

  # Only admin users can see DELETED sports
  DELETED
}

# Represent an interval of String
type StringInterval {
  # The lower bound of the interval
  from: String

  # The upper bound of the interval
  to: String
}

# Represent an interval input of String
input StringIntervalInput {
  # The lower bound of the interval
  from: String!

  # The upper bound of the interval
  to: String!
}

# Represent a translated String
input StringTranslatedInput {
  # The translation for this string in FR
  FR: String

  # The translation for this string in EN
  EN: String

  # The translation for this string in DE
  DE: String

  # The translation for this string in ES
  ES: String
}

# List of sub accounts with corresponding tokens
type SubAccounts {
  # Id
  id: String

  # Pseudo
  pseudo: String

  # Avatar
  avatar: String

  # Gives the number of unread notifications for this user
  numberOfUnreadNotifications: Int

  # Gives the number of unread chats for this user
  unreadChats: Int

  # Token for this user
  token: String
}

type Subscription {
  addMsgSubscription(input: addMsgSubscriptionInput!): addMsgSubscriptionPayload
  unreadChatsSubscription(input: unreadChatsSubscriptionInput!): unreadChatsSubscriptionPayload
  newNotificationSubscription(input: newNotificationSubscriptionInput!): newNotificationSubscriptionPayload
  unreadNotificationsSubscription(input: unreadNotificationsSubscriptionInput!): unreadNotificationsSubscriptionPayload
  updateSportunitySubscription(input: updateSportunitySubscriptionInput!): updateSportunitySubscriptionPayload
}

# Super user object
type SuperUser {
  # Id of the super user
  id: String

  # Pseudo of the super user
  pseudo: String

  # Avatar of the super user
  avatar: String

  # Tells if current user is already a subaccount
  isSubAccount: Boolean

  # The type of the super user
  profileType: UserProfileType

  # The user preferences
  userPreferences: SuperUserPreferences

  # Gives the number of unread notifications for this user
  numberOfUnreadNotifications: Int

  # Gives the number of unread chats for this user
  unreadChats: Int

  # List of sub accounts with corresponding tokens
  subAccounts: [SubAccounts]
}

# The user preferences
type SuperUserPreferences {
  # Allow the user to create sub-accounts if activated
  areSubAccountsActivated: Boolean
}

# Represent any language Sportunity supports
enum supportedCountries {
  CH
  FR
}

# Represent any language Sportunity supports
enum SupportedLanguage {
  FR
  EN
  DE
  ES
}

type Survey {
  # Tells if the survey has been transformed to an event
  isSurveyTransformed: Boolean

  # List of dates for a survey
  surveyDates: [SurveyDatesOutput]
}

# Represent a user invited to a Sportunity
type SurveyAnswer {
  # Return a Users for a given id
  user: User

  # Tells the answer of the invited user
  answer: invitedUserAnswer
}

# Represents a date for a survey
input SurveyDatesInput {
  # Beginning date of the proposition
  beginning_date: String

  # Ending date of the proposition
  ending_date: String
}

# Represents a date for a survey
type SurveyDatesOutput {
  # Beginning date of the proposition
  beginning_date: String

  # Ending date of the proposition
  ending_date: String

  # List of answers
  answers: [SurveyAnswer]
}

# Represents a date for a survey
input SurveyDatesUpdateInput {
  # Beginning date of the proposition
  beginning_date: String

  # Ending date of the proposition
  ending_date: String
}

input SurveyInvitedAnswers {
  # The beginning date of the proposition
  beginning_date: String

  # The ending date of the proposition
  ending_date: String

  # Answer to the survey
  answer: invitedUserAnswer!
}

type TermsOfUseAcceptedBy {
  # Return a Users for a given id
  user: User

  # Date of user acceptation
  acceptedDate: DateTime
}

input testEmailTemplateInput {
  # Id of the user you want to send this email to
  userId: String!

  # Id of the sportunity if needed
  sportunityId: String

  # ID of the template
  templateId: String!
  placeholders: [Placeholders]
  clientMutationId: String
}

type testEmailTemplatePayload {
  result: Boolean
  clientMutationId: String
}

# Total amount on the wallet
type TotalAmountOnWallet {
  # The currency in which this amount was set
  currency: Currency

  # The amount on current user's wallet
  cents: Int
}

# Represent a translated 
type Translated {
  # The ID of an object
  id: ID!

  # Get a SporLevel
  FR: SportLevel

  # Get a SporLevel
  EN: SportLevel

  # Get a SporLevel
  DE: SportLevel

  # Get a SporLevel
  ES: SportLevel
}

# Represent a translated String
type TranslatedString {
  # The ID of an object
  id: ID!

  # The translation for this string in FR
  FR: String

  # The translation for this string in EN
  EN: String

  # The translation for this string in DE
  DE: String

  # The translation for this string in ES
  ES: String
}

input unfollowUserInput {
  # Id of the user to unfollow
  userID: String
  clientMutationId: String
}

type unfollowUserPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input unreadChatsSubscriptionInput {
  clientSubscriptionId: String
}

type unreadChatsSubscriptionPayload {
  unreadChats: Int
  user: User
  viewer: Viewer
  clientSubscriptionId: String
}

input unreadNotificationsSubscriptionInput {
  clientSubscriptionId: String
}

type unreadNotificationsSubscriptionPayload {
  unreadNotifications: Int
  user: User
  viewer: Viewer
  clientSubscriptionId: String
}

input updateAskedInformationFormInput {
  id: String
  name: String!
  circleIds: [String]!
  askedInformation: [AskedInformationInput]
  clientMutationId: String
}

type updateAskedInformationFormPayload {
  viewer: Viewer
  clientMutationId: String
}

input updateAskedInformationInput {
  circleId: String!
  askedInformation: [AskedInformation]
  clientMutationId: String
}

type updateAskedInformationPayload {
  edge: CircleEdge
  viewer: Viewer
  clientMutationId: String
}

input updateAssistantTypeInput {
  # ID of the assistant type to update
  assistantTypeID: String!

  # The translation for the updated assistant type linked to a sport
  name: StringTranslatedInput
  clientMutationId: String
}

type updateAssistantTypePayload {
  assistantType: AssistantType
  viewer: Viewer
  clientMutationId: String
}

input updateCarPoolingInput {
  # The ID of the sportunity
  sportunityID: String!

  # The ID of the car-pooling to update
  carPoolingID: String!

  # Car pooling input type
  carPooling: CarPoolingInput
  clientMutationId: String
}

type updateCarPoolingPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

input updateCircleInput {
  # The ID of the circle to update
  circleId: String!

  # A Circle input type
  circle: CircleInput
  clientMutationId: String
}

input updateCircleMemberStatusInput {
  circleId: String!
  memberStatus: [MemberStatusInput]
  clientMutationId: String
}

type updateCircleMemberStatusPayload {
  edge: CircleEdge
  circle: Circle
  viewer: Viewer
  clientMutationId: String
}

type updateCirclePayload {
  edge: CircleEdge
  viewer: Viewer
  clientMutationId: String
}

input updateCirclePaymentModelInput {
  paymentModel: CirclePaymentModelInput
  clientMutationId: String
}

type updateCirclePaymentModelPayload {
  viewer: Viewer
  clientMutationId: String
}

input updateCircleTermsOfUseInput {
  termsOfUse: CircleTermsOfUseInput
  clientMutationId: String
}

type updateCircleTermsOfUsePayload {
  viewer: Viewer
  termsOfUse: CircleTermsOfUse
  clientMutationId: String
}

input updateCompositionInput {
  # The ID of the composition to update
  compositionId: String

  # A User input type
  composition: CompositionInput
  clientMutationId: String
}

type updateCompositionPayload {
  user: User
  composition: CompositionOutput
  viewer: Viewer
  clientMutationId: String
}

input updateFilledInformationInput {
  circleId: String!
  answers: [Answers]
  clientMutationId: String
}

type updateFilledInformationPayload {
  edge: CircleEdge
  viewer: Viewer
  clientMutationId: String
}

input updateInfrastructureInput {
  infrastructure: InfrastructureInput
  clientMutationId: String
}

type updateInfrastructurePayload {
  edge: VenueEdge
  viewer: Viewer
  clientMutationId: String
}

input updatePasswordInput {
  # Old password, that will be changed by new password
  oldPassword: String!

  # New password
  newPassword: String!
  clientMutationId: String
}

type updatePasswordPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input updateSlotInput {
  slot: SlotInput

  # Tells if the serie of slot should be updated
  updateSlotSerie: Boolean
  clientMutationId: String
}

type updateSlotPayload {
  edge: VenueEdge
  viewer: Viewer
  clientMutationId: String
}

input updateSportInput {
  # The ID of the sport to update
  sportID: String!

  # a Sport input type
  sport: SportUpdateInput
  clientMutationId: String
}

type updateSportPayload {
  edge: SportEdge
  viewer: Viewer
  clientMutationId: String
}

input updateSportunityCompositionsInput {
  # The ID of the sportunity to update
  sportunityId: String

  # The IDs of the composition to assign
  compositionIds: [String]
  clientMutationId: String
}

type updateSportunityCompositionsPayload {
  edge: SportunityEdge
  viewer: Viewer
  sportunity: Sportunity
  clientMutationId: String
}

input updateSportunityInput {
  # The ID of the sportunity to update
  sportunityID: String!

  # A Sportunity input type
  sportunity: SportunityUpdateInput

  # Tells if participants & invitees should be notified for this change
  notify_people: Boolean
  clientMutationId: String
}

type updateSportunityPayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}

input updateSportunityStatisticsInput {
  # ID of the sportunity
  sportunityID: String!

  # Statistics for the sportunity
  sportunityStatistics: [SportunityStatisticInput]
  clientMutationId: String
}

type updateSportunityStatisticsPayload {
  sportunityStatistics: [Statistic]
  viewer: Viewer
  clientMutationId: String
}

input updateSportunitySubscriptionInput {
  # The ID of the sportunity to subscribe to
  sportunityId: String
  clientSubscriptionId: String
}

type updateSportunitySubscriptionPayload {
  sportunity: Sportunity
  viewer: Viewer
  clientSubscriptionId: String
}

input updateSportunityTemplateInput {
  # Id of the template to update
  sportunityTemplateId: String!

  # A Sportunity template input type
  sportunityTemplate: SportunityTemplateInput
  clientMutationId: String
}

type updateSportunityTemplatePayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input updateSportunityTypeInput {
  # ID of the sportunity type to update
  sportunityTypeID: String!

  # The translation for the updated type for an event linked to a sport
  name: StringTranslatedInput

  # Tells if a score can be set on this sportunity type
  isScoreRelevant: Boolean
  clientMutationId: String
}

type updateSportunityTypePayload {
  sportunityType: SportunityType
  viewer: Viewer
  clientMutationId: String
}

input updateSportunityTypeStatusInput {
  # ID of the sportunity type status to udpate
  sportunityTypeStatusID: String!

  # The translation of updated status for a type for an event linked to a sport
  name: StringTranslatedInput!
  clientMutationId: String
}

type updateSportunityTypeStatusPayload {
  sportunityTypeStatus: SportunityTypeStatus
  viewer: Viewer
  clientMutationId: String
}

input updateStatisticFilterInput {
  # Id of the filter to update
  statisticFilterId: String!

  # Name of the filter
  name: String!

  # Beginning date of the filter
  date_begin: String

  # Ending date of the filter
  date_end: String

  # List of circles of the filter
  circleList: [String]
  clientMutationId: String
}

type updateStatisticFilterPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

input updateStatisticPreferencesInput {
  # Statistic preferences input type
  statisticPreferences: StatisticPreferencesInput

  # ID of the user
  userID: String!
  clientMutationId: String
}

type updateStatisticPreferencesPayload {
  statisticPreferences: StatisticPreferences
  viewer: Viewer
  clientMutationId: String
}

# Represents a user update input type
input UpdateUserInput {
  # First name of the user
  firstName: String

  # Last name of the user
  lastName: String

  # The unique pseudo of the user
  pseudo: String

  # The unique email of the user
  email: Email

  # The password of the user
  password: String

  # Country of the user
  appCountry: supportedCountries

  # Currency of the user
  appCurrency: Currency

  # List of language ids spoken by the current user
  languages: [String]

  # The language of user's app
  appLanguage: SupportedLanguage

  # Description of the user
  description: String

  # The avatar url ot the user
  avatar: String

  # The ids of the users which are blacklisted
  blackList: [String]

  # The id of the user who wants to follow current User
  followers: String

  # The phone prefix of the user
  phonePrefix: Int

  # The phone number of the user
  phoneNumber: Int

  # Birthday of the user
  birthday: String

  # If the user decides not to show his age to other users
  hideMyAge: Boolean

  # The gender of the user
  sex: Sex

  # Address of the user
  address: AddressInput

  # Public address of the user
  publicAddress: AddressInput

  # Fees to apply to user if he organizes a sportunity (20% -> 20)
  fees: Int

  # List of sports that the user plays
  sports: [SportDescriptorInput]

  # Tells if the user has a validated email address
  isEmailValidated: Boolean

  # The status of current user
  creation_status: UserStatusInput

  # Add a new Feedback to the user
  feedbacks: [FeedbackInput]

  # Save a filter
  savedFilters: [UserFilterInput]

  # Save a circle filter
  savedCircleFilters: [SavedCircleFilterInput]

  # Tells if the basic filters have been created
  basicSavedFiltersCreated: Boolean

  # Tells if the basic circle filters have been created
  basicCircleSavedFiltersCreated: Boolean

  # The user’s nationality
  nationality: String

  # User's occupation, ie. Work
  occupation: String

  # Could be only one of these values: 
  #               1 - for incomes <18K€), 
  #               2 - for incomes between 18 and 30K€, 
  #               3 - for incomes between 30 and 50K€, 
  #               4 - for incomes between 50 and 80K€, 
  #               5 - for incomes between 80 and 120K€, 
  #               6 - for incomes >120K€
  incomeRange: Int

  # If the user is a business, then those fields are needed
  business: BusinessInput

  # Tells if the user has to declare VAT
  shouldDeclareVAT: Boolean
  authorized_managers: [AuthorizedManagerInput]

  # List of sportunities or users the current user added to his calendar
  calendar: CalendarInput

  # Let the user choose if he wants to receive notifications
  notification_preferences: NotificationPreferencesInput

  # Let the user choose if he wants to receive emails
  email_preferences: EmailPreferencesInput

  # Tells if the user activated his statistics module
  areStatisticsActivated: Boolean

  # Tells if the user activated the availability statistics for his participants
  areAvailabilityStatisticsActivated: Boolean

  # Tells if the user activated the terms of use for his circles
  areTermsOfUseActivated: Boolean

  # Tells if the user activated his compositions module
  areCompositionsActivated: Boolean

  # Tells the prefered page when user logs in
  homePagePreference: HomePagePreference

  # The user preferences
  userPreferences: UserPreferencesInput
}

input updateVenueInput {
  # The ID of the venue to update
  venueId: String

  # A Venue update input type
  venue: VenueUpdateInput
  clientMutationId: String
}

type updateVenuePayload {
  edge: VenueEdge
  viewer: Viewer
  clientMutationId: String
}

input upUserInput {
  # The ID of the user to update
  userID: String

  # Token to change password
  token: String

  # A User input type
  user: UpdateUserInput
  clientMutationId: String
}

type upUserPayload {
  user: User
  viewer: Viewer
  clientMutationId: String
}

# A Sportunity User
type User implements Node {
  # The ID of an object
  id: ID!

  # The token of the user
  token: String!

  # The first name of the user.
  #
  #         Auth: Restricted
  #         
  firstName: String

  # The last name of the user.
  #
  #         Auth: Restricted
  #         
  lastName: String

  # The pseudo of the user
  #
  #     Example: blop
  #     
  #     Auth: Public
  pseudo: String!

  # The email of the user
  #
  #         Auth: Private
  #       
  email: Email

  # The avatar link of the user
  #
  #       Auth: Private
  #       
  avatar: String

  # Inform if the profile is complete considering the user's type
  isProfileComplete: Boolean

  # Return a bunch of Users for a given array of id
  blackList: [User]

  # Return a bunch of Users for a given array of id
  followers: [User]

  # Return the list of languages the current user speaks
  languages: [Language]

  # The language of user's app
  appLanguage: SupportedLanguage

  # Country of the user
  appCountry: supportedCountries

  # Currency of the user
  appCurrency: Currency

  # Description of the user
  description: String

  # The country prefix of the user's phone
  #
  #       Example: 41
  #
  #       Auth: Restricted
  #       
  phonePrefix: Int

  # The country phone number of the user. What comes after the prefix
  #
  #       Example: 789757676
  #
  #       Auth: Restricted
  #       
  phoneNumber: Int

  # The birthday of the user
  #
  #       Auth: Restricted
  birthday: DateTime

  # Tells if the user wants to show his age to other people or not
  #       
  #       Auth: Public
  hideMyAge: Boolean

  # The sex of the user (MALE or FEMALE)
  #
  #       Auth: Public
  #       
  sex: Sex!

  # The address of a user
  address: AddressModel

  # The address of a user
  publicAddress: AddressModel

  # The list of all venues that current user owns
  venues(
    after: String
    first: Int
    before: String
    last: Int

    # Description of a filter in Sportunity
    filter: Filter
  ): VenueConnection

  # The list of sport descriptor of a user
  sports: [SportDescriptor]

  # Get the feedbacks for the given object
  feedbacks: Feedbacks

  # The list of all circles belonging to a given object
  circles(
    after: String
    first: Int
    before: String
    last: Int

    # Types of wanted circles
    type: [CircleTypeEnum]

    # Description of a filter in Sportunity
    filter: CirclesFilter
  ): CircleConnection

  # The list of circles the current user is in
  circlesUserIsIn(
    after: String
    first: Int
    before: String
    last: Int

    # Description of a filter in Sportunity
    filter: CirclesFilter
  ): CircleConnection

  # The list of circles subaccounts of the current user own
  circlesSuperUser(
    after: String
    first: Int
    before: String
    last: Int

    # Description of a filter in Sportunity
    filter: CirclesFilter
  ): CircleConnection

  # The list of circles from the club (only if current user is a team from a club)
  circlesFromClub(
    after: String
    first: Int
    before: String
    last: Int

    # Types of wanted circles
    type: [CircleTypeEnum]

    # Description of a filter in Sportunity
    filter: CirclesFilter
  ): CircleConnection

  # The list of all members from all the current user's circles
  allCircleMembers: [CircleMemberOutput]

  # The list of forms for personal information asked for circles
  circleInformationForms: [CircleInformationFormOutput]

  # The list of payment models for circles
  circlePaymentModels: [CirclePaymentModel]

  # The list of all Sportunities
  sportunities(
    after: String
    first: Int
    before: String
    last: Int

    # Description of a filter in Sportunity
    filter: Filter

    # ID of the user we want to chat with
    userId: String

    # ID of the sportunity wanted
    id: String
    orderBy: Sportunities_Order
  ): SportunityConnection

  # The number of sportunities the user organized and booked in the past
  sportunityNumber: Int

  # The list of all chats of the user
  chats(
    after: String
    first: Int
    before: String
    last: Int

    # ID of the chat wanted
    id: ID
  ): ChatConnection

  # Tells if the user has a validated email address
  isEmailValidated: Boolean

  # Get the number of unread chats for current User
  unreadChats: Int
  mangoId: String

  # Fees to apply to user if he organizes a sportunity (20% -> 20)
  fees: Int

  # Get the list of users that reported current user
  reporters: [ReporterUser]
  creation_status: UserCreationStatus

  # The list of all notifications sent to this entity
  notifications(after: String, first: Int, before: String, last: Int): NotificationConnection

  # List payment methods for current user
  paymentMethods: [PaymentMethod]

  # The bank account registred for current user
  bankAccount: BankAccount

  # Get the number of unread chats for current User
  savedFilters: [UserFilter]

  # Get the number of unread chats for current User
  defaultSavedFilter: UserFilter

  # Tells if the basic filters have been created
  basicSavedFiltersCreated: Boolean

  # Tells if the basic circle filters have been created
  basicCircleSavedFiltersCreated: Boolean

  # Get the saved circle filters
  savedCircleFilters: [UserCircleFilter]

  # Get the default circle filter
  defaultSavedCircleFilter: UserCircleFilter

  #
  #         Last time the user get connected
  #       
  lastConnexionDate: DateTime

  # The type of user
  profileType: UserProfileType

  # The user’s nationality
  nationality: String

  # User's occupation, ie. Work
  occupation: String

  # Could be only one of these values: 
  #           1 - for incomes <18K€), 
  #           2 - for incomes between 18 and 30K€, 
  #           3 - for incomes between 30 and 50K€, 
  #           4 - for incomes between 50 and 80K€, 
  #           5 - for incomes between 80 and 120K€, 
  #           6 - for incomes >120K€
  incomeRange: Int

  # If the user is a business, then those fields are needed
  business: Business

  # Tells if the user has to declare VAT
  shouldDeclareVAT: Boolean

  # Return a bunch of Users for a given array of id
  subAccounts: [User]

  # Return a master account
  masterAccount: User
  authorized_managers: [AuthorizedManager]

  # Tells if current user is already a subaccount
  isSubAccount: Boolean
  calendar: Calendar

  # The list of all Sportunity templates for current user
  sportunityTemplates: [SportunityTemplate]

  # Gives the number of unread notifications for current user
  numberOfUnreadNotifications: Int
  notification_preferences: NotificationPreferences

  # Let the user choose if he wants to receive emails
  email_preferences: EmailPreferences

  # Tells if the current user has activated his statistics module
  areStatisticsActivated: Boolean

  # Tells if the user activated the availability statistics for his participants
  areAvailabilityStatisticsActivated: Boolean

  # Tells if the user activated the terms of use for his circles
  areTermsOfUseActivated: Boolean

  # Returns the ToU for a specified user
  termsOfUses: [CircleTermsOfUse]

  # Tells if the user activated his compositions module
  areCompositionsActivated: Boolean

  # Get the Compositions of a user / event
  compositions: [CompositionOutput]

  # Get the statistic preferences for current User
  statisticPreferences(
    # ID of the user
    userID: String
  ): StatisticPreferences

  # Get the statistic filters of a user
  statisticFilters: [StatisticFilter]

  # Returns the statistics for a specified user
  userStatistics: UserStatistics

  # Prefered home page
  homePagePreference: HomePagePreference

  # Tells if the current user can manage a venue
  userCanManageVenue: Boolean

  # Tells if the current user can test some specific features
  beta_tester: BetaTester

  # The user preferences
  userPreferences: UserPreferences

  # Tells if the user can query sportunityType filter
  canQuerySportunityTypeFilter: Boolean
}

# For each user, gives the list of sportunity status the user want to synchronize
type User_Status {
  # Return a Users for a given id
  user: User

  # Array of status of sportunities
  statuses: [SportunityStatus]
}

# Represent a user's preference for his participant's availability
input UserAvailabilityStatsPrefsInput {
  # 1st stat
  stat1: String

  # 2nd stat
  stat2: String

  # 3rd stat
  stat3: String

  # 4th stat
  stat4: String

  # 5th stat
  stat5: String
}

# The filters that a user saved for circles
type UserCircleFilter {
  # The ID of an object
  id: ID!

  # The name of the filter
  filterName: String
  location: CircleFilterLatLng
  sport: [CircleFilterSport]

  # Circle type
  circleType: [CircleListTypeEnum]

  # The type of the members
  memberType: CircleTypeEnum

  # Types of members (adults, children, ...)
  memberTypes: [CircleTypeEnum]

  # The kind of Circle
  modes: [CircleKind]

  # Return a bunch of Users for a given array of id
  owners: [User]

  # Is circle usable by member
  isCircleUsableByMember: Boolean

  # Position of the filter in the list
  position: Int
}

# A connection to a list of items.
type UserConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [UserEdge]

  # Total number of tags
  count: Int
}

# Creation status of this user
type UserCreationStatus {
  # The status of current user
  status: userStatus

  # Tells the reason of the current status
  reason: String
}

# An edge in a connection.
type UserEdge {
  # The item at the end of the edge
  node: User

  # A cursor for use in pagination
  cursor: String!
}

# The filters that a user saved
type UserFilter {
  # The ID of an object
  id: ID!

  # The name of the filter
  filterName: String
  location: FilterLatLng
  sport: [FilterSport]

  # Return a price: NumberInterval
  price: IntInterval

  # Return a dates: StringInterval
  dates: StringInterval

  # Return a hours: NumberInterval
  hours: IntInterval

  # Status of sportunities
  status: SportunityStatus

  # Array of status of sportunities
  statuses: [SportunityStatus]

  # Page this filter is for
  page: HomePagePreference

  # Return a bunch of Users for a given array of id
  subAccounts: [User]

  # Get the available types of events for a sport
  sportunityTypes(
    # Sport type to get the event types possible
    sportType: SportTypeEnum
  ): [SportunityType]

  # Return a bunch of Users for a given array of id
  users: [User]

  # Position of the filter in the list
  position: Int
}

# Save a filter
input UserFilterInput {
  # Id of the filter
  userFilterId: String

  # Name of the filter
  filterName: String

  # Filter by location constraint
  location: LocationConstraint

  # Filter by sport name and level constraint
  sport: [SportConstraint]

  # The interval of price to filter
  price: IntIntervalInput

  # The interval of dates to filter
  dates: StringIntervalInput

  # The interval of hours of the beginning hours to filter
  hours: IntIntervalInput

  # Status of sportunities
  status: SportunityStatus

  # Array of status of sportunities
  statuses: [SportunityStatus]

  # Tells the page where this filter can be applied to
  page: HomePagePreference

  # ID of the sub-accounts to get their sportunities
  subAccounts: [String]

  # List of IDs of sportunity types to filter
  sportunityTypes: [String]

  # ID of the users to get their sportunities
  users: [String]

  # The position of this filter in the list
  position: Int
}

# Represents a user input type
input UserInput {
  # First name of the user
  firstName: String

  # Last name of the user
  lastName: String

  # The unique pseudo of the user
  pseudo: String!

  # The unique email of the user
  email: Email

  # The password of the user
  password: String

  # List of language ids spoken by the current user
  languages: [String]

  # The language of user's app
  appLanguage: SupportedLanguage

  # The country of the user
  appCountry: supportedCountries

  # The currency of the user
  appCurrency: Currency

  # Description of the user
  description: String

  # The avatar url ot the user
  avatar: String

  # The phone prefix of the user
  phonePrefix: Int

  # The phone number of the user
  phoneNumber: Int

  # Birthday of the user
  birthday: String

  # The gender of the user
  sex: Sex!

  # Address of the user
  address: AddressInput

  # Fees to apply to user if he organizes a sportunity (20% -> 20)
  fees: Int

  # List of sports that the user plays
  sports: [SportDescriptorInput]

  # The type of user
  profileType: UserProfileType

  # List of subaccounts pseudos
  subAccountsPseudoList: [String]
}

# The user preferences
type UserPreferences {
  # Allow the user to create sub-accounts if activated
  areSubAccountsActivated: Boolean
}

# The user preferences
input UserPreferencesInput {
  # Allow the user to create sub-accounts if activated
  areSubAccountsActivated: Boolean
}

# Status of an event, for the current user
enum UserProfileType {
  # Natural user
  PERSON

  # Business user
  BUSINESS

  # Organization user
  ORGANIZATION

  # Soletrader user
  SOLETRADER
}

# User statistics object
type UserStatistics {
  # Gives the number of activities user participated
  numberOfParticipated: Int

  # Gives the number of activities user participated in a week
  averageNumberOfParticipatedWeek: Float

  # Gives the number of activities user participated in a month
  averageNumberOfParticipatedMonth: Float

  # Gives the number of activities user participated in a year
  averageNumberOfParticipatedYear: Float

  # Gives the number of activities user organized in a week
  averageNumberOfOrganizedWeek: Float

  # Gives the number of activities user organized in a month
  averageNumberOfOrganizedMonth: Float

  # Gives the number of activities user organized in a year
  averageNumberOfOrganizedYear: Float

  # Gives the percentage of organized activites versus booked activities (max 100)
  percentageOfOrganized: Float

  # Gives the note of behavior - very bad : 0, very good : 4
  globalNote: Int

  # Return a averageTime: TranslatedString
  averageTime: TranslatedString
  steps: [UserStatisticsSteps]

  # Tells if the user has been participating / cancelling
  hasData: Boolean
  membersUserParticipatesWith: [MembersUserParticipatesWith]
}

# The number of booking / canceling for each step
type UserStatisticsSteps {
  # Return a step: TranslatedString
  step: TranslatedString

  # The number of booking / canceling during the time interval
  value: Int
}

# Represent a user's preference for his participant's stats
type userStats {
  # Get the current statistic
  stat0: StatisticName

  # Get the current statistic
  stat1: StatisticName

  # Get the current statistic
  stat2: StatisticName

  # Get the current statistic
  stat3: StatisticName

  # Get the current statistic
  stat4: StatisticName

  # Get the current statistic
  stat5: StatisticName

  # Get the current statistic
  statManOfTheGame: StatisticName
}

# Represent a user's preference for his participant's stats
input UserStatsPrefsInput {
  # 1st stat
  stat1: String

  # 2nd stat
  stat2: String

  # 3rd stat
  stat3: String

  # 4th stat
  stat4: String

  # 5th stat
  stat5: String
}

# List of available status for a user
enum userStatus {
  # Can access to all functionnalities of the app
  VALID

  # A suspended user can't login
  SUSPENDED

  # A deleted user can't login
  DELETED
}

# Represents a user status input type
input UserStatusInput {
  # The current status of the user
  status: userStatus

  # The reason of current status
  reason: String
}

# List of creation status for a sportunity or an event
enum ValidationStatus {
  # Waiting to be verificated by an admin (old)
  PENDING

  # Venue or sportunity has been validated by an admin
  VALIDATED

  # Venue or sportunity has been rejected by an admin : users won't see it
  REJECTED

  # Waiting to be verificated by an admin (new)
  TO_BE_VALIDATED
}

# A venue for a Sportunity
type Venue implements Node {
  # The ID of an object
  id: ID!

  # The name of the Venue
  name: String!

  # The full description of the Venue
  description: String!

  # The address of a user
  address: AddressModel

  # Return a Users for a given id
  owner: User

  # Get the feedbacks for the given object
  feedbacks: Feedbacks

  # The Infrastructures of a given object
  infrastructures(
    # Description of a filter in Sportunity
    filter: Filter
  ): [Infrastructure]

  # Logo of the venue
  logo: String

  # Get the Prices of an object
  price: Price
  creation_status: VenueCreationStatus
}

# A connection to a list of items.
type VenueConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [VenueEdge]

  # Total number of tags
  count: Int
}

# Creation status of this venue
type VenueCreationStatus {
  # The status of current venue
  status: ValidationStatus

  # Tells the reason of the current status
  reason: String
}

# An edge in a connection.
type VenueEdge {
  # The item at the end of the edge
  node: Venue

  # A cursor for use in pagination
  cursor: String!
}

# Represents a venue input type
input VenueInput {
  # Name of the venue
  name: String!

  # Description of the venue
  description: String!

  # Address id of the venue
  address: AddressInput!

  # Owner id of the venue
  owner: String

  # Feedbacks on the venue
  feedbacks: [FeedbackInput]

  # Logo of the venue
  logo: String

  # The price to create a sportunity in this venue
  price: PriceInput
}

# Represents a venue status input type
input VenueStatusInput {
  # The current status of the venue
  status: ValidationStatus

  # The reason of current status
  reason: String
}

# Represents a venue update input type
input VenueUpdateInput {
  # Name of the venue
  name: String

  # Description of the venue
  description: String

  # Address id of the venue
  address: AddressInput

  # Owner id of the venue
  owner: String

  # Feedbacks on the venue
  feedbacks: [FeedbackInput]

  # Infrastructures of the venue
  infrastructures: [InfrastructureInput]

  # Logo of the venue
  logo: String

  # The price to create a sportunity in this venue
  price: PriceInput

  # The status of current venue
  creation_status: VenueStatusInput
}

# Represents the viewer
type Viewer implements Node {
  # The viewer Id
  id: ID!

  # Get a sport for object that have only one
  sport(
    # ID of the sport wanted
    id: ID
  ): Sport

  # The list of all sports on the platform
  sports(
    after: String
    first: Int
    before: String
    last: Int

    # Description of a filter in Sport
    filter: SportFilter

    # IDs of the sports wanted
    ids: [String]

    # Language of the sport's name (to sort them)
    language: SupportedLanguage
  ): SportConnection

  # Get the available types of events for a sport
  sportunityTypes(
    # Sport type to get the event types possible
    sportType: SportTypeEnum
  ): [SportunityType]

  # Return a User for a given id
  user(
    # The id of the object you want to retrieve
    id: String!
  ): User

  # Return the currently logged in user
  me: User

  # The list of all users on the platform
  users(
    # Used to get users pseudo autocompletion
    pseudo: String

    # Used to search users by email
    email: String

    # Used to search users by profile type
    userType: UserProfileType

    # Search only parents
    parentsOnly: Boolean

    # Filter by sport name and level constraint
    sport: [SportConstraint]
    after: String
    first: Int
    before: String
    last: Int
  ): UserConnection

  # Check if a user exists, given his pseudo or email
  userExists(
    # Pseudo of the user to check
    pseudo: String

    # Email of the user to check
    email: String

    # Used to search users by profile type
    userType: UserProfileType
  ): Boolean

  # The list of all assistants for a specific sport / assistant type
  assistants(
    # Sport requested
    sportId: String!

    # Assistant type requested
    assistantTypeId: String
    after: String
    first: Int
    before: String
    last: Int
  ): UserConnection

  # Returns superUser information with the token sent
  superMe(
    # Token of the user logged in
    superToken: String
  ): SuperUser

  # Returns accounts that current user can connect to
  authorizedAccounts(
    # Token of the user logged in
    userToken: String
  ): AuthorizedAccounts

  # A circle
  circle(
    # ID of the circle wanted
    id: ID
  ): Circle

  # The list of all public circles
  circles(
    after: String
    first: Int
    before: String
    last: Int

    # Description of a filter in Sportunity
    filter: CirclesFilter
  ): CircleConnection

  # User personal reference for payment models
  circlePersonalReference(
    # Id of the circle
    circleId: String!
  ): String

  # Return the list of languages
  languages: [Language]

  # Get all languages supported by the app
  supportedLanguages: [String]

  # A Sportunity
  sportunity(
    # ID of the sportunity wanted
    id: ID
  ): Sportunity

  # The list of all Sportunities
  sportunities(
    after: String
    first: Int
    before: String
    last: Int

    # Description of a filter in Sportunity
    filter: Filter

    # ID of the user we want to chat with
    userId: String

    # ID of the sportunity wanted
    id: String
    orderBy: Sportunities_Order
  ): SportunityConnection

  # The list of all organizers of sportunities
  sportunitiesOrganizers(
    after: String
    first: Int
    before: String
    last: Int

    # Description of a filter in Sportunity
    filter: Filter

    # ID of the user we want to chat with
    userId: String

    # ID of the sportunity wanted
    id: String
    orderBy: SportunitiesOrganizers_Order
  ): UserConnection

  # Get the status of the sportunity for current User
  sportunityStatus(
    # ID of the sportunity wanted
    sportunityId: String

    # ID of the user to get his status
    userId: String
  ): String

  # The list of all opponent for a specific sport
  opponents(
    # Used to get users pseudo autocompletion
    pseudo: String

    # Sport requested
    sportId: String
    after: String
    first: Int
    before: String
    last: Int
  ): UserConnection

  # The list of all my opponents for a specific sport
  myOpponents(
    # Used to get users pseudo autocompletion
    pseudo: String

    # Sport requested
    sportId: String
    after: String
    first: Int
    before: String
    last: Int
  ): UserConnection

  # Get a venue for object that have only one
  venue(
    # ID of the sportunity wanted
    id: ID
  ): Venue

  # The list of all venues on Sportunity
  venues(
    after: String
    first: Int
    before: String
    last: Int

    # Description of a filter in Sportunity
    filter: Filter
  ): VenueConnection

  # Get the infrastructure of an object
  infrastructure(
    # ID of the infrastructure wanted
    id: ID
  ): Infrastructure

  # The Infrastructures of a given object
  infrastructures(
    # Description of a filter in Sportunity
    filter: Filter
  ): [Infrastructure]

  # The a list slots
  slots(
    # ID of the infrastructure we want the avaialbe slots of
    id: ID

    # ID of the sportunity user is updating
    updatingSportunity: ID

    # Description of a filter in Sportunity
    filter: Filter
  ): [Slot]

  # The list of all messages in a discussion
  chat(
    after: String
    first: Int
    before: String
    last: Int

    # ID of the chat
    id: String

    # ID of the user we want to chat with
    userId: String

    # ID of the sportunity
    sportunityId: String

    # ID of the circle
    circleId: String
  ): Chat

  # The list of all chats of the user
  chats(
    after: String
    first: Int
    before: String
    last: Int

    # ID of the chat wanted
    id: ID
  ): ChatConnection

  # Ask Mango Pay to register a new card
  cardRegistration: cardRegistration

  # Ask Mango Pay to register a bank wire
  bankwireToWallet(
    # The amount the user wants to cash in
    amount: PriceInput!
  ): BankWireToWallet

  # Ask Mango Pay to get the amount on current user's wallet
  amountOnWallet: AmountOnWallet

  # Request an invoice for a specific user & sportunity
  requestInvoice(
    # Id of the sportunity
    sportunityID: String!
  ): Boolean

  # Sends a new mail to users that are invited to a sportunity
  relaunchInviteds(
    # ID of the sportunity
    sportunityID: String!
  ): Sportunity

  # Get the statistic preferences for current User
  statisticPreferences(
    # ID of the user
    userID: String
  ): StatisticPreferences

  # Get the statistics for a sportunity
  sportunityStatistics(
    # ID of the sportunity
    sportunityID: String
  ): [Statistic]

  # Get the statistics for a user
  circlesStatistics(
    # ID of the user
    userID: String

    # ID of the circle
    circleID: String

    # Stats on multiple circle
    circlesIDs: [String]

    # The interval of dates to filter
    dateInterval: StringIntervalInput

    # Type of the sportunities wanted (match, training, ...)
    eventType: String
  ): [CirclesStatisticsOrganizer]

  # Get the statistics for a user
  sportunitiesStatistics(
    # ID of the user
    userID: String
  ): [SportunitiesStatisticsOrganizer]

  # Global statistics for the application
  AdminStatistics: AdminStatistics

  # Tells if current user is co-organizer on a serie or not
  IsCoOrganizerOnSerie(
    # Id of the sportunity
    sportunityId: String!
  ): Boolean

  # Returns a Composition for a given id
  composition(
    # The id of the object you want to retrieve
    id: String!
  ): CompositionOutput

  # The list of owners of circles the current user is in
  ownersOfCirclesUserIsIn(after: String, first: Int, before: String, last: Int): UserConnection

  # Get the content of a short url
  url(
    # Short url to convert to long one
    shortUrl: String
  ): String

  # Create a short url from a long one
  createShortUrl(
    # Long url to convert
    url: String!
  ): String
}

input voteForManOfTheGameInput {
  # ID of the sportunity
  sportunityID: String!

  # ID of the participant current user is voting for
  participantID: String!
  clientMutationId: String
}

type voteForManOfTheGamePayload {
  edge: SportunityEdge
  viewer: Viewer
  clientMutationId: String
}
